<!doctype html>
<html lang="en-us">
  <head>
	<title>A quick and dirty experiment on compiling Batari Basic programs on the Browser.</title>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css">  
  </head>
  <body>
	<h1 class="title">A quick and dirty experiment on compiling Batari Basic programs on the Browser.</h1>
  
	<style>
		textarea {
			white-space: pre;
		}
		
		.fill-vertically {
			height: 60vh;
			overflow-y: auto;
		}
		
		.full-height {
			height: 100%;
		}
		
		.full-height-without-heading.textarea[rows] {
			height: calc(100% - 3em);
		}
		
		.footer {
			padding: 0;
		}
		
		.float-right {
			float: right;
		}
	</style>

	<div class="columns is-mobile">

		<div class="column fill-vertically">
			<div class="panel full-height is-primary">
				<p class="panel-heading">
					Input
                    <button id="compile-button" class="button is-outlined is-small float-right">
					  <span>▶️ Compile</span>
					</button>
				</p>
				<textArea id="input" class="textarea is-family-code full-height-without-heading" rows="10">
 rem Hello World

 playfield:
................................
......X.X.XXX.X...X...XXX.......
......X.X.X...X...X...X.X.......
......XXX.XX..X...X...X.X.......
......X.X.X...X...X...X.X.......
......X.X.XXX.XXX.XXX.XXX.......
................................
.....X...X.XXX.XX..X...XX.......
.....X...X.X.X.X.X.X...X.X......
.....X.X.X.X.X.XX..X...X.X......
.....XX.XX.XXX.X.X.XXX.XX.......
end

 COLUPF = 22
 COLUBK = 2

mainloop
 drawscreen
 score = score + 1
 goto mainloop

				</textArea>
			</div>
		</div>

		<div id="output" class="column fill-vertically">
		
			<div class="panel is-warning">
				<p class="panel-heading">Loading</p>
				<textArea id="preprocess" class="textarea is-family-code">Please wait...</textArea>
			</div>
			
		</div>
		
		<div class="column fill-vertically is-success">
			<div class="panel is-success">
				<p class="panel-heading">Results</p>
				<div class="block"></div>
				<div class="block">
					<button id="downloadROM" class="button is-success" disabled>Download ROM</button>
				</div>
				<div id="javatari" class="block">
					<div id="javatari-screen"></div>
				</div>
			</div>
		</div>
	</div>
	
	<footer class="footer">
		<div class="panel is-danger">
			<p class="panel-heading">Errors</p>
			<textArea id="error" class="textarea is-family-code has-text-danger" style="color: red"></textArea>
		</div>
	</footer>
  
    <script type="text/javascript" src="bb2600basic.js"></script>
    <script type="text/javascript" src="bbpreprocess.js"></script>
    <script type="text/javascript" src="dasm.js"></script>
    <script type="text/javascript" src="fsContents.js"></script>
    <script type="text/javascript" src="FileSaver.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/underscore@1.12.0/underscore-min.js"></script>
	
	<script type="text/javascript">
		Module = { 
			  preRun: function() {
				var position = 0;
				var source = document.getElementById('input').value;
				var out = document.getElementById('output');
				var err = document.getElementById('error');
				
				out.value = '';
				err.value = '';
			  
				function stdin() {
					var ch = position >= source.length ? null : source.charCodeAt(position);
					console.log('stdin', ch);
					position++;
					return ch;
				}

				function stdout(asciiCode) {
					window.blah += String.fromCharCode(asciiCode);
					out.value = out.value + String.fromCharCode(asciiCode);
				}

				function stderr(asciiCode) {
					err.value = err.value + String.fromCharCode(asciiCode);
				}

				FS.init(stdin, stdout, stderr);
				
				FS.writeFile("default.inc", "\nbB.asm\n");
			  },
			  
			  noInitialRun: true
		};
		
		var OUTPUT_TEMPLATE = Handlebars.compile(
					'{{#each contents}}' +
					'	<div class="panel is-{{type}}"><p class="panel-heading">{{name}}</p>' +
					'		<textArea class="textarea is-family-code" readonly>{{content}}</textArea>' +
					'	</div>' +
					'{{/each}}');
		function updateOutput(contents, type) {
			document.getElementById('output').innerHTML = OUTPUT_TEMPLATE({
				contents: Object.entries(contents).map(([name, content]) => ({name, content, type})), 		
			});
		}
		
		function clearOutput() {
			updateOutput({'Compiling': 'Please wait...'}, 'warning');
			document.getElementById('downloadROM').disabled = true;
			document.getElementById('error').value = '';
		}
		
		function setupStdin(fs, code) {
			var i = 0;
			fs.init(function () { return i < code.length ? code.charCodeAt(i++) : null; });
		}
		
		function stderr(asciiCode) {
			var err = document.getElementById('error');
			err.value = err.value + String.fromCharCode(asciiCode);
		}
		
		async function loadFileSystem() {
			const metadata = (await fetch('fs2600basic.js.metadata')).json();
			const content = (await fetch('fs2600basic.data')).blob();
			const files = metadata.files.map(({filename, start, end}) => ({
				filename, start, end,
				content: null
			}));
			return files;
		}
		
		function prepareException(mainMessage, errors) {
			var err = new Error(main);
			err.errors = errors;
			return err;
		}

		function preprocessBatariBasic(code) {
			var bbout = "";
			function addbbout_fn(s) {
				bbout += s;
				bbout += "\n";
			}
			
			var errors = [];
			function adderror_fn(s) {
				errors.push(s);
			}
			
			var BBPRE = preprocess({
				noInitialRun: true,
				//logReadFiles:true,
				print: addbbout_fn,
				printErr: adderror_fn,
				noFSInit: true,
			});
			var FS = BBPRE['FS'];
			setupStdin(FS, code);
			BBPRE.callMain([]);
			if (errors.length) {
				throw prepareException("Errors while preprocessing.", errors);
			}
			console.log("preprocess " + code.length + " -> " + bbout.length + " bytes");
			return bbout;
		}
		
		function execMain(mod, args) {
			var run = mod.callMain || mod.run; // TODO: run?
			run(args);
		}
		
		// To obtain the JSON: JSON.stringify(Object.fromEntries(Object.keys(FS.lookupPath('/share/includes', {}).node.contents).map(name => ([name, FS.readFile('/share/includes/' + name, {encoding: 'utf8'})]))))
		
		function compileBatariBasic(code) {
			// stdout
			var asmout = "";
			function addasmout_fn(s) {
				asmout += s;
				asmout += "\n";
			}
			// stderr
			var re_err1 = /[(](\d+)[)]:?\s*(.+)/;
			var errors = [];
			var errline = 0;
			function match_fn(s) {
				console.log(s);
				var matches = re_err1.exec(s);
				if (matches) {
					errline = parseInt(matches[1]);
					errors.push({
						line: errline,
						msg: matches[2]
					});
				}
			}
			//gatherFiles(step, { mainFilePath: "main.bas" });
			//var destpath = step.prefix + '.asm';
			var destpath = 'main.asm';			
			//if (staleFiles(step, [destpath])) {
			{
				var BB = bb2600basic({
					noInitialRun: true,
					//logReadFiles:true,
					print: addasmout_fn,
					printErr: match_fn,
					noFSInit: true,
					TOTAL_MEMORY: 64 * 1024 * 1024,
				});
				var FS = BB['FS'];
				//populateFiles(FS);
				// preprocess, pipe file to stdin
				/*
				var code = getWorkFileAsString(step.path);
				code = preprocessBatariBasic(code);
				*/
				FS.mkdir('share');
				FS.mkdir('share/includes');
				Object.entries(DEFAULT_INCLUDES).forEach(([name, content]) => {
					FS.writeFile('share/includes/' + name, content, { encoding: 'utf8' });
				});
				
				setupStdin(FS, code);
				FS.writeFile('main.bas', code, { encoding: 'utf8' });
				//setupFS(FS, '2600basic');
				execMain(BB, ["-i", "/share", 'main.bas']);
				if (errors.length) {
					throw prepareException("Errors while compiling.", errors);
				}
					
				// build final assembly output from include file list
				var includesout = FS.readFile("includes.bB", { encoding: 'utf8' });
				var redefsout = FS.readFile("2600basic_variable_redefs.h", { encoding: 'utf8' });
				var includes = includesout.trim().split("\n");
				var combinedasm = "";
				var splitasm = asmout.split("bB.asm file is split here");
				for (var _i = 0, includes_1 = includes; _i < includes_1.length; _i++) {
					var incfile = includes_1[_i];
					var inctext;
					if (incfile == "bB.asm")
						inctext = splitasm[0];
					else if (incfile == "bB2.asm")
						inctext = splitasm[1];
					else
						inctext = FS.readFile("/share/includes/" + incfile, { encoding: 'utf8' });
					console.log(incfile, inctext.length);
					combinedasm += "\n\n;;;" + incfile + "\n\n";
					combinedasm += inctext;
				}
				
				/*
				// TODO: ; bB.asm file is split here
				putWorkFile(destpath, combinedasm);
				putWorkFile("2600basic.h", FS.readFile("/share/includes/2600basic.h"));
				putWorkFile("2600basic_variable_redefs.h", redefsout);
				*/
					
				return {
					'main.asm': combinedasm,
					'2600basic.h': FS.readFile("/share/includes/2600basic.h", { encoding: 'utf8' }),
					'2600basic_variable_redefs.h': redefsout
				};
			}
			/*
			return {
				nexttool: "dasm",
				path: destpath,
				args: [destpath],
				files: [destpath, "2600basic.h", "2600basic_variable_redefs.h"],
				bblines: true,
			};
			*/
		}
		
		// test.c(6) : warning 85: in function main unreferenced local variable : 'x'
		// main.a (4): error: Unknown Mnemonic 'xxx'.
		// at 2: warning 190: ISO C forbids an empty source file
		var re_msvc = /[/]*([^( ]+)\s*[(](\d+)[)]\s*:\s*(.+?):\s*(.*)/;
		var re_msvc2 = /\s*(at)\s+(\d+)\s*(:)\s*(.*)/;
		function msvcErrorMatcher(errors) {
			return function (s) {
				var matches = re_msvc.exec(s) || re_msvc2.exec(s);
				if (matches) {
					var errline = parseInt(matches[2]);
					errors.push({
						line: errline,
						path: matches[1],
						//type:matches[3],
						msg: matches[4]
					});
				}
				else {
					console.log(s);
				}
			};
		}
		
		// TODO: "of" doesn't work in MSIE
		var re_crlf = /\r?\n/;
		//    1   %line 16+1 hello.asm
		var re_lineoffset = /\s*(\d+)\s+[%]line\s+(\d+)\+(\d+)\s+(.+)/;

		function parseDASMListing(code, listings, errors, unresolved) {
			// TODO: this gets very slow
			//        4  08ee		       a9 00	   start      lda	#01workermain.js:23:5
			var lineMatch = /\s*(\d+)\s+(\S+)\s+([0-9a-f]+)\s+([?0-9a-f][?0-9a-f ]+)?\s+(.+)?/i;
			var equMatch = /\bequ\b/i;
			var macroMatch = /\bMAC\s+(.+)?/i;
			var macrolines = [];
			var lastline = 0;
			var macros = {};
			for (var _i = 0, _a = code.split(re_crlf); _i < _a.length; _i++) {
				var line = _a[_i];
				var linem = lineMatch.exec(line);
				if (linem && linem[1]) {
					var linenum = parseInt(linem[1]);
					var filename = linem[2];
					var offset = parseInt(linem[3], 16);
					var insns = linem[4];
					var restline = linem[5];
					if (insns && insns.startsWith('?'))
						insns = null;
					// inside of a file?
					var lst = listings[filename];
					if (lst) {
						var lines = lst.lines;
						// look for MAC statement
						var macmatch = macroMatch.exec(restline);
						if (macmatch) {
							macros[macmatch[1]] = { line: parseInt(linem[1]), file: linem[2].toLowerCase() };
						}
						else if (insns && !restline.match(equMatch)) {
							lines.push({
								line: linenum,
								offset: offset,
								insns: insns,
								iscode: restline[0] != '.'
							});
						}
						lastline = linenum;
					}
					else {
						// inside of macro or include file
						if (insns && linem[3] && lastline > 0) {
							lines.push({
								line: lastline + 1,
								offset: offset,
								insns: null
							});
						}
						// inside of macro?
						var mac = macros[filename.toLowerCase()];
						if (insns && mac) {
							macrolines.push({
								filename: mac.file,
								line: mac.line + linenum,
								offset: offset,
								insns: insns
							});
						}
					}
					// TODO: better symbol test (word boundaries)
					// TODO: ignore IFCONST and IFNCONST usage
					for (var key in unresolved) {
						var l = restline || line;
						var pos = l.indexOf(key);
						if (pos >= 0) {
							var cmt = l.indexOf(';');
							if (cmt < 0 || cmt > pos) {
								// make sure identifier is flanked by non-word chars
								if (/\w+/.test(key) && new RegExp("\\b" + key + "\\b").test(key)) {
									errors.push({
										path: filename,
										line: linenum,
										msg: "Unresolved symbol '" + key + "'"
									});
								}
							}
						}
					}
				}
				var errm = re_msvc.exec(line);
				if (errm) {
					errors.push({
						path: errm[1],
						line: parseInt(errm[2]),
						msg: errm[4]
					});
				}
			}
			// TODO: use macrolines
		}

		function assembleDASM(assemblyFiles) {
			var re_usl = /(\w+)\s+0000\s+[?][?][?][?]/;
			var unresolved = {};
			var errors = [];
			var errorMatcher = msvcErrorMatcher(errors);
			function match_fn(s) {
				// TODO: what if s is not string? (startsWith is not a function)
				var matches = re_usl.exec(s);
				if (matches) {
					var key = matches[1];
					if (key != 'NO_ILLEGAL_OPCODES') { // TODO
						unresolved[matches[1]] = 0;
					}
				}
				else if (s.startsWith("Warning:")) {
					errors.push({ line: 0, msg: s.substr(9) });
				}
				else if (s.startsWith("unable ")) {
					errors.push({ line: 0, msg: s });
				}
				else {
					errorMatcher(s);
				}
			}
			var Module = DASM({
				noInitialRun: true,
				print: match_fn
			});
			var FS = Module['FS'];

			Object.entries(assemblyFiles).forEach(([name, content]) => FS.writeFile(name, content, { 'encoding': 'utf8' }));
			/*
			populateFiles(step, FS, {
				mainFilePath: 'main.a'
			});
			*/
			
			var binpath = 'main.bin';
			var lstpath = 'main.lst';
			var sympath = 'main.sym';
			execMain(Module, ['main.asm', '-f3',
				"-l" + lstpath,
				"-o" + binpath,
				"-s" + sympath]);
			var alst = FS.readFile(lstpath, { 'encoding': 'utf8' });
			// parse main listing, get errors and listings for each file
			var listings = {};
			for (var _i = 0, _a = Object.keys(assemblyFiles); _i < _a.length; _i++) {
				var path = _a[_i];
				listings[path] = { lines: [] };
			}
			parseDASMListing(alst, listings, errors, unresolved);
			if (errors.length) {
				return { errors: errors };
			}
			// read binary rom output and symbols
			var aout, asym;
			aout = FS.readFile(binpath);
			try {
				asym = FS.readFile(sympath, { 'encoding': 'utf8' });
			}
			catch (e) {
				console.log(e);
				errors.push({ line: 0, msg: "No symbol table generated, maybe segment overflow?" });
				return { errors: errors };
			}
			/*
			putWorkFile(binpath, aout);
			putWorkFile(lstpath, alst);
			putWorkFile(sympath, asym);
			*/
			// return unchanged if no files changed
			// TODO: what if listing or symbols change?
			//if (!anyTargetChanged(step, [binpath /*, lstpath, sympath*/]))
			//	return;
			var symbolmap = {};
			for (var _b = 0, _c = asym.split("\n"); _b < _c.length; _b++) {
				var s = _c[_b];
				var toks = s.split(/\s+/);
				if (toks && toks.length >= 2 && !toks[0].startsWith('-')) {
					symbolmap[toks[0]] = parseInt(toks[1], 16);
				}
			}
			// for bataribasic (TODO)
			/*			
			if (step['bblines']) {
				var lst = listings[step.path];
				if (lst) {
					lst.asmlines = lst.lines;
					lst.text = alst;
					lst.lines = [];
				}
			}
			*/
			if (errors.length) {
				throw prepareException("Errors while assembling.", errors);
			}
			
			return {
				output: aout,
				listings: listings,
				symbolmap: symbolmap,
			};
		}
		
		function executeApplication() {
		
			var remainingTries = 3;
			function tryRunning() {
				try {
					clearOutput();
				
					var source = document.getElementById('input').value;
									
					var preprocessed = preprocessBatariBasic(source);				
					console.info('Preprocessing results', preprocessed);
					var preprocessedResults = {'Preprocessed': preprocessed};
					updateOutput(preprocessedResults, 'info');
					
					var assemblyFiles = compileBatariBasic(preprocessed);				
					console.info('Assembly files generated from BASIC source', assemblyFiles);
					/*
					document.getElementById('outputMarker').outerHTML = Object.entries(assemblyFiles).map(([name, content]) => {
						return '<div class="panel is-info"><p class="panel-heading">' + name + '</p>' +
						'<textArea class="textarea is-family-code">' + content + '</textArea>' +
						'</div>';
					}).join();
					*/
					updateOutput(Object.assign({}, preprocessedResults, assemblyFiles), 'info');
					
					var assemblyOutputs = assembleDASM(assemblyFiles);
					console.info('Output files generated from assemblies', assemblyOutputs);
					
					var downloadButton = document.getElementById('downloadROM');
					downloadButton.onclick = () => saveAs(new Blob([assemblyOutputs.output]), 'generated-rom.bin');
					downloadButton.disabled = false;
					
					Javatari.fileLoader.loadFromContent('main.bin', assemblyOutputs.output);
				} catch (e) {
					console.error('Error while compiling', e);
					document.getElementById('error').value = e;
				}
			}
			
			var inputArea = document.getElementById('input');
			var inputEvent = _.debounce(tryRunning, 300);
			inputArea.onchange = inputEvent;
			inputArea.onkeyup = inputEvent;
			document.getElementById('compile-button').onclick = inputEvent;
			
			console.log('First try...');
			tryRunning();
			
		}
	</script>
	<script>
		setTimeout(executeApplication, 1000);
	</script>
	<script src="javatari.js"></script>
  </body>
</html>
