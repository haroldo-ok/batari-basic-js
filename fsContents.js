window.DEFAULT_INCLUDES = {
   "2600basicfooter.asm":" ifconst bankswitch\n   if bankswitch == 8\n     ORG $2FFC\n     RORG $FFFC\n   endif\n   if bankswitch == 16\n     ORG $4FFC\n     RORG $FFFC\n   endif\n   if bankswitch == 32\n     ORG $8FFC\n     RORG $FFFC\n   endif\n else\n   ifconst ROM2k\n     ORG $F7FC\n   else\n     ORG $FFFC\n   endif\n endif\n .word start\n .word start\n",
   "macro.h":"; MACRO.H\r\n; Version 1.05, 13/NOVEMBER/2003\r\n\r\nVERSION_MACRO         = 105\r\n\r\n;\r\n; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE\r\n; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!\r\n;\r\n; This file defines DASM macros useful for development for the Atari 2600.\r\n; It is distributed as a companion machine-specific support package\r\n; for the DASM compiler. Updates to this file, DASM, and associated tools are\r\n; available at at http://www.atari2600.org/dasm\r\n;\r\n; Many thanks to the people who have contributed.  If you take issue with the\r\n; contents, or would like to add something, please write to me\r\n; (atari2600@taswegian.com) with your contribution.\r\n;\r\n; Latest Revisions...\r\n;\r\n; 1.05  14/NOV/2003      - Added VERSION_MACRO equate (which will reflect 100x version #)\r\n;                          This will allow conditional code to verify MACRO.H being\r\n;                          used for code assembly.\r\n; 1.04  13/NOV/2003     - SET_POINTER macro added (16-bit address load)\r\n;\r\n; 1.03  23/JUN/2003     - CLEAN_START macro added - clears TIA, RAM, registers\r\n;\r\n; 1.02  14/JUN/2003     - VERTICAL_SYNC macro added\r\n;                         (standardised macro for vertical synch code)\r\n; 1.01  22/MAR/2003     - SLEEP macro added. \r\n;                       - NO_ILLEGAL_OPCODES switch implemented\r\n; 1.0\t22/MAR/2003\t\tInitial release\r\n\r\n; Note: These macros use illegal opcodes.  To disable illegal opcode usage, \r\n;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).\r\n;   If you do not allow illegal opcode usage, you must include this file \r\n;   *after* including VCS.H (as the non-illegal opcodes access hardware\r\n;   registers and require them to be defined first).\r\n\r\n; Available macros...\r\n;   SLEEP n             - sleep for n cycles\r\n;   VERTICAL_SYNC       - correct 3 scanline vertical synch code\r\n;   CLEAN_START         - set machine to known state on startup\r\n;   SET_POINTER         - load a 16-bit absolute to a 16-bit variable\r\n\r\n;-------------------------------------------------------------------------------\r\n; SLEEP duration\r\n; Original author: Thomas Jentzsch\r\n; Inserts code which takes the specified number of cycles to execute.  This is\r\n; useful for code where precise timing is required.\r\n; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.\r\n; LEGAL OPCODE VERSION MAY AFFECT FLAGS\r\n; Uses illegal opcode (DASM 2.20.01 onwards).\r\n\r\n            MAC SLEEP            ;usage: SLEEP n (n>1)\r\n.CYCLES     SET {1}\r\n\r\n                IF .CYCLES < 2\r\n                    ECHO \"MACRO ERROR: 'SLEEP': Duration must be > 1\"\r\n                    ERR\r\n                ENDIF\r\n\r\n                IF .CYCLES & 1\r\n                    IFNCONST NO_ILLEGAL_OPCODES\r\n                        nop 0\r\n                    ELSE\r\n                        bit VSYNC\r\n                    ENDIF\r\n.CYCLES             SET .CYCLES - 3\r\n                ENDIF\r\n            \r\n                REPEAT .CYCLES / 2\r\n                    nop\r\n                REPEND\r\n            ENDM\r\n\r\n;-------------------------------------------------------------------------------\r\n; VERTICAL_SYNC\r\n; Original author: Manuel Polik\r\n; Inserts the code required for a proper 3 scannline \r\n; vertical sync sequence\r\n;\r\n; Note: Alters the accumulator\r\n;\r\n; IN:\r\n; OUT: A = 1\r\n\r\n            MAC VERTICAL_SYNC\r\n                LDA #$02            ; A = VSYNC enable\r\n                STA WSYNC           ; Finish current line\r\n                STA VSYNC           ; Start vertical sync\r\n                STA WSYNC           ; 1st line vertical sync\r\n                STA WSYNC           ; 2nd line vertical sync\r\n                LSR                 ; A = VSYNC disable\r\n                STA WSYNC           ; 3rd line vertical sync\r\n                STA VSYNC           ; Stop vertical sync\r\n            ENDM\r\n\r\n;-------------------------------------------------------------------------------\r\n; CLEAN_START\r\n; Original author: Andrew Davie\r\n; Standardised start-up code, clears stack, all TIA registers and RAM to 0\r\n; Sets stack pointer to $FF, and all registers to 0\r\n; Sets decimal mode off, sets interrupt flag (kind of un-necessary)\r\n; Use as very first section of code on boot (ie: at reset)\r\n; Code written to minimise total ROM usage - uses weird 6502 knowledge :)\r\n\r\n            MAC CLEAN_START\r\n                sei\r\n                cld\r\n            \r\n                ldx #0\r\n                txa\r\n                tay\r\n.CLEAR_STACK    dex\r\n                txs\r\n                pha\r\n                bne .CLEAR_STACK     ; SP=$FF, X = A = Y = 0\r\n\r\n            ENDM\r\n\r\n;-------------------------------------------------------\r\n; SET_POINTER\r\n; Original author: Manuel Rotschkar\r\n;\r\n; Sets a 2 byte RAM pointer to an absolute address.\r\n;\r\n; Usage: SET_POINTER pointer, address\r\n; Example: SET_POINTER SpritePTR, SpriteData\r\n;\r\n; Note: Alters the accumulator, NZ flags\r\n; IN 1: 2 byte RAM location reserved for pointer\r\n; IN 2: absolute address\r\n\r\n            MAC SET_POINTER\r\n.POINTER    SET {1}\r\n.ADDRESS    SET {2}\r\n\r\n                LDA #<.ADDRESS  ; Get Lowbyte of Address\r\n                STA .POINTER    ; Store in pointer\r\n                LDA #>.ADDRESS  ; Get Hibyte of Address\r\n                STA .POINTER+1  ; Store in pointer+1\r\n\r\n            ENDM\r\n\r\n; EOF\r\n",
   "bankswitch.inc":"; this file is screwed, I accidentally deleted the comments.  Restore with version in .99b zip file.\n2600basicheader.asm\nbB.asm\nstd_kernel.asm\nstartup.asm\npf_drawing.asm\npf_scrolling.asm\nstd_routines.asm\nstd_overscan.asm\nbB2.asm\nscore_graphics.asm\nbanksw.asm\n2600basicfooter.asm\n",
   "6lives.asm":"minikernel ; display up to 6 lives on screen\n sta WSYNC\n sleep 10 ; can we optimize this?\n lda #0\n ldy #7\n sta VDELP0\n sta VDELP1\n ifnconst lives_compact\n ifnconst lives_centered\n sta RESP0\n endif\n lda.w lives\n ifnconst lives_centered\n sta RESP1\n endif\n lsr\n lsr\n lsr\n lsr\n ifconst lives_centered\n sta RESP0\n endif\n lsr\n tax\n ifconst lives_centered\n sta RESP1\n endif\n lda lifenusiz0table,x\n sta NUSIZ0\n lda lifenusiz1table,x\n sta NUSIZ1\n lda lifecolor\n sta COLUP0\n sta COLUP1\n lda #$b0\n sta HMP0\n\n else\n\n ifnconst lives_centered\n sta.w RESP0\n sta RESP1\n endif\n lda lives\n lsr\n lsr\n lsr\n lsr\n lsr\n tax\n lda lifenusiz0table,x\n ifconst lives_centered\n sta RESP0\n sta RESP1\n sta.w NUSIZ0\n else\n sta NUSIZ0\n endif\n lda lifenusiz1table,x\n sta NUSIZ1\n lda lifecolor\n sta COLUP0\n sta COLUP1\n lda #$10\n sta HMP1\n\n endif\n\n sta HMOVE ; cycle 73\n\nlifeloop\n cpx #0\n beq skipall\n lda (lifepointer),y\n sta GRP0\n cpx #1\n beq skipall\n sta GRP1\nskipall\n dey\n sta WSYNC\n bpl lifeloop\n iny\n sty GRP0\n sty GRP1\n rts\n\n if (<*) > $F5\n align 256\n endif\n ifconst lives_compact\nlifenusiz1table\n .byte 0\nlifenusiz0table\n .byte 0,0,0,1,1,3,3,3\n else\nlifenusiz1table\n .byte 0\nlifenusiz0table\n .byte 0,0,0,2,2,6,6,6\n endif\n",
   "vcs.h":"; VCS.H\r\n; Version 1.05, 13/November/2003\r\n\r\nVERSION_VCS         = 105\r\n\r\n; THIS IS A PRELIMINARY RELEASE OF *THE* \"STANDARD\" VCS.H\r\n; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE\r\n; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!\r\n;\r\n; This file defines hardware registers and memory mapping for the\r\n; Atari 2600. It is distributed as a companion machine-specific support package\r\n; for the DASM compiler. Updates to this file, DASM, and associated tools are\r\n; available at at http://www.atari2600.org/dasm\r\n;\r\n; Many thanks to the original author(s) of this file, and to everyone who has\r\n; contributed to understanding the Atari 2600.  If you take issue with the\r\n; contents, or naming of registers, please write to me (atari2600@taswegian.com)\r\n; with your views.  Please contribute, if you think you can improve this\r\n; file!\r\n;\r\n; Latest Revisions...\r\n; 1.05  13/NOV/2003      - Correction to 1.04 - now functions as requested by MR.\r\n;                        - Added VERSION_VCS equate (which will reflect 100x version #)\r\n;                          This will allow conditional code to verify VCS.H being\r\n;                          used for code assembly.\r\n; 1.04  12/NOV/2003     Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for\r\n;                       convenient disassembly/reassembly compatibility for hardware\r\n;                       mirrored reading/writing differences.  This is more a \r\n;                       readability issue, and binary compatibility with disassembled\r\n;                       and reassembled sources.  Per Manuel Rotschkar's suggestion.\r\n; 1.03  12/MAY/2003     Added SEG segment at end of file to fix old-code compatibility\r\n;                       which was broken by the use of segments in this file, as\r\n;                       reported by Manuel Polik on [stella] 11/MAY/2003\r\n; 1.02  22/MAR/2003     Added TIMINT($285)\r\n; 1.01\t        \t\tConstant offset added to allow use for 3F-style bankswitching\r\n;\t\t\t\t\t\t - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise\r\n;\t\t\t\t\t\t   it is safe to leave it undefined, and the base address will\r\n;\t\t\t\t\t\t   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.\r\n;                          Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS\r\n;                        - register definitions are now generated through assignment\r\n;                          in uninitialised segments.  This allows a changeable base\r\n;                          address architecture.\r\n; 1.0\t22/MAR/2003\t\tInitial release\r\n\r\n\r\n;-------------------------------------------------------------------------------\r\n\r\n; TIA_BASE_ADDRESS\r\n; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.\r\n; Normally 0, the base address should (externally, before including this file)\r\n; be set to $40 when creating 3F-bankswitched (and other?) cartridges.\r\n; The reason is that this bankswitching scheme treats any access to locations\r\n; < $40 as a bankswitch.\r\n\r\n\t\t\tIFNCONST TIA_BASE_ADDRESS\r\nTIA_BASE_ADDRESS\t= 0\r\n\t\t\tENDIF\r\n\r\n; Note: The address may be defined on the command-line using the -D switch, eg:\r\n; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin\r\n; *OR* by declaring the label before including this file, eg:\r\n; TIA_BASE_ADDRESS = $40\r\n;   include \"vcs.h\"\r\n\r\n; Alternate read/write address capability - allows for some disassembly compatibility\r\n; usage ; to allow reassembly to binary perfect copies).  This is essentially catering\r\n; for the mirrored ROM hardware registers.\r\n\r\n; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS\r\n; using the -D command-line switch, as required.  If the addresses are not defined, \r\n; they defaut to the TIA_BASE_ADDRESS.\r\n\r\n     IFNCONST TIA_BASE_READ_ADDRESS\r\nTIA_BASE_READ_ADDRESS = TIA_BASE_ADDRESS\r\n     ENDIF\r\n\r\n     IFNCONST TIA_BASE_WRITE_ADDRESS\r\nTIA_BASE_WRITE_ADDRESS = TIA_BASE_ADDRESS\r\n     ENDIF\r\n\r\n;-------------------------------------------------------------------------------\r\n\r\n\t\t\tSEG.U TIA_REGISTERS_WRITE\r\n\t\t\tORG TIA_BASE_WRITE_ADDRESS\r\n\r\n\t; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!\r\n    \r\nVSYNC       ds 1    ; $00   0000 00x0   Vertical Sync Set-Clear\r\nVBLANK\t\tds 1\t; $01   xx00 00x0   Vertical Blank Set-Clear\r\nWSYNC\t\tds 1\t; $02   ---- ----   Wait for Horizontal Blank\r\nRSYNC\t\tds 1\t; $03   ---- ----   Reset Horizontal Sync Counter\r\nNUSIZ0\t\tds 1\t; $04   00xx 0xxx   Number-Size player/missle 0\r\nNUSIZ1\t\tds 1\t; $05   00xx 0xxx   Number-Size player/missle 1\r\nCOLUP0\t\tds 1\t; $06   xxxx xxx0   Color-Luminance Player 0\r\nCOLUP1      ds 1    ; $07   xxxx xxx0   Color-Luminance Player 1\r\nCOLUPF      ds 1    ; $08   xxxx xxx0   Color-Luminance Playfield\r\nCOLUBK      ds 1    ; $09   xxxx xxx0   Color-Luminance Background\r\nCTRLPF      ds 1    ; $0A   00xx 0xxx   Control Playfield, Ball, Collisions\r\nREFP0       ds 1    ; $0B   0000 x000   Reflection Player 0\r\nREFP1       ds 1    ; $0C   0000 x000   Reflection Player 1\r\nPF0         ds 1    ; $0D   xxxx 0000   Playfield Register Byte 0\r\nPF1         ds 1    ; $0E   xxxx xxxx   Playfield Register Byte 1\r\nPF2         ds 1    ; $0F   xxxx xxxx   Playfield Register Byte 2\r\nRESP0       ds 1    ; $10   ---- ----   Reset Player 0\r\nRESP1       ds 1    ; $11   ---- ----   Reset Player 1\r\nRESM0       ds 1    ; $12   ---- ----   Reset Missle 0\r\nRESM1       ds 1    ; $13   ---- ----   Reset Missle 1\r\nRESBL       ds 1    ; $14   ---- ----   Reset Ball\r\nAUDC0       ds 1    ; $15   0000 xxxx   Audio Control 0\r\nAUDC1       ds 1    ; $16   0000 xxxx   Audio Control 1\r\nAUDF0       ds 1    ; $17   000x xxxx   Audio Frequency 0\r\nAUDF1       ds 1    ; $18   000x xxxx   Audio Frequency 1\r\nAUDV0       ds 1    ; $19   0000 xxxx   Audio Volume 0\r\nAUDV1       ds 1    ; $1A   0000 xxxx   Audio Volume 1\r\nGRP0        ds 1    ; $1B   xxxx xxxx   Graphics Register Player 0\r\nGRP1        ds 1    ; $1C   xxxx xxxx   Graphics Register Player 1\r\nENAM0       ds 1    ; $1D   0000 00x0   Graphics Enable Missle 0\r\nENAM1       ds 1    ; $1E   0000 00x0   Graphics Enable Missle 1\r\nENABL       ds 1    ; $1F   0000 00x0   Graphics Enable Ball\r\nHMP0        ds 1    ; $20   xxxx 0000   Horizontal Motion Player 0\r\nHMP1        ds 1    ; $21   xxxx 0000   Horizontal Motion Player 1\r\nHMM0        ds 1    ; $22   xxxx 0000   Horizontal Motion Missle 0\r\nHMM1        ds 1    ; $23   xxxx 0000   Horizontal Motion Missle 1\r\nHMBL        ds 1    ; $24   xxxx 0000   Horizontal Motion Ball\r\nVDELP0      ds 1    ; $25   0000 000x   Vertical Delay Player 0\r\nVDELP1      ds 1    ; $26   0000 000x   Vertical Delay Player 1\r\nVDELBL      ds 1    ; $27   0000 000x   Vertical Delay Ball\r\nRESMP0      ds 1    ; $28   0000 00x0   Reset Missle 0 to Player 0\r\nRESMP1      ds 1    ; $29   0000 00x0   Reset Missle 1 to Player 1\r\nHMOVE       ds 1    ; $2A   ---- ----   Apply Horizontal Motion\r\nHMCLR       ds 1    ; $2B   ---- ----   Clear Horizontal Move Registers\r\nCXCLR       ds 1    ; $2C   ---- ----   Clear Collision Latches\r\n \r\n;-------------------------------------------------------------------------------\r\n\r\n\t\t\tSEG.U TIA_REGISTERS_READ\r\n\t\t\tORG TIA_BASE_READ_ADDRESS\r\n\r\n                    ;\t\t\t\t\t\t\t\t\t\t\tbit 7   bit 6\r\nCXM0P       ds 1    ; $00       xx00 0000       Read Collision  M0-P1   M0-P0\r\nCXM1P       ds 1    ; $01       xx00 0000                       M1-P0   M1-P1\r\nCXP0FB      ds 1    ; $02       xx00 0000                       P0-PF   P0-BL\r\nCXP1FB      ds 1    ; $03       xx00 0000                       P1-PF   P1-BL\r\nCXM0FB      ds 1    ; $04       xx00 0000                       M0-PF   M0-BL\r\nCXM1FB      ds 1    ; $05       xx00 0000                       M1-PF   M1-BL\r\nCXBLPF      ds 1    ; $06       x000 0000                       BL-PF   -----\r\nCXPPMM      ds 1    ; $07       xx00 0000                       P0-P1   M0-M1\r\nINPT0       ds 1    ; $08       x000 0000       Read Pot Port 0\r\nINPT1       ds 1    ; $09       x000 0000       Read Pot Port 1\r\nINPT2       ds 1    ; $0A       x000 0000       Read Pot Port 2\r\nINPT3       ds 1    ; $0B       x000 0000       Read Pot Port 3\r\nINPT4       ds 1    ; $0C\t\tx000 0000       Read Input (Trigger) 0\r\nINPT5       ds 1\t; $0D\t\tx000 0000       Read Input (Trigger) 1\r\n\r\n;-------------------------------------------------------------------------------\r\n\r\n\t\t\tSEG.U RIOT\r\n\t\t\tORG $280\r\n \r\n\t; RIOT MEMORY MAP\r\n\r\nSWCHA       ds 1    ; $280      Port A data register for joysticks:\r\n\t\t\t\t\t;\t\t\tBits 4-7 for player 1.  Bits 0-3 for player 2.\r\n\r\nSWACNT      ds 1    ; $281      Port A data direction register (DDR)\r\nSWCHB       ds 1    ; $282\t\tPort B data (console switches)\r\nSWBCNT      ds 1    ; $283      Port B DDR\r\nINTIM       ds 1    ; $284\t\tTimer output\r\n\r\nTIMINT  \tds 1\t; $285\r\n\r\n\t\t; Unused/undefined registers ($285-$294)\r\n\r\n\t\t\tds 1\t; $286\r\n\t\t\tds 1\t; $287\r\n\t\t\tds 1\t; $288\r\n\t\t\tds 1\t; $289\r\n\t\t\tds 1\t; $28A\r\n\t\t\tds 1\t; $28B\r\n\t\t\tds 1\t; $28C\r\n\t\t\tds 1\t; $28D\r\n\t\t\tds 1\t; $28E\r\n\t\t\tds 1\t; $28F\r\n\t\t\tds 1\t; $290\r\n\t\t\tds 1\t; $291\r\n\t\t\tds 1\t; $292\r\n\t\t\tds 1\t; $293\r\n\r\nTIM1T       ds 1    ; $294\t\tset 1 clock interval\r\nTIM8T       ds 1    ; $295      set 8 clock interval\r\nTIM64T      ds 1    ; $296      set 64 clock interval\r\nT1024T      ds 1    ; $297      set 1024 clock interval\r\n\r\n;-------------------------------------------------------------------------------\r\n; The following required for back-compatibility with code which does not use\r\n; segments.\r\n\r\n            SEG\r\n\r\n; EOF\r\n",
   "superchip.inc":"; this file is screwed, I accidentally deleted the comments.  Restore with version in .99b zip file.\nsuperchipheader.asm\nbB.asm\nstd_kernel.asm\nstartup.asm\npf_drawing.asm\npf_scrolling.asm\nstd_routines.asm\nstd_overscan.asm\nbB2.asm\nscore_graphics.asm\nbanksw.asm\n2600basicfooter.asm\n",
   "div_mul16.asm":"; Compute mul1*mul2+acc -> acc:mul1 [mul2 is unchanged]\n; Routine courtesy of John Payson (AtariAge member supercat)\n \n ; x and a contain multiplicands, result in a, temp1 contains any overflow\n\nmul16\n sty temp1\n sta temp2\n ldx #8\n dec temp2\nloopmul\n lsr\n ror temp1\n bcc noaddmul\n adc temp2\nnoaddmul\n dex\n bne loopmul\n RETURN\n\n; div int/int\n; numerator in A, denom in temp1\n; returns with quotient in A, remainder in temp1\n\ndiv16\n sty temp1\n  ldx #8\nloopdiv\n cmp temp1\n bcc toosmalldiv\n sbc temp1   ; Note: Carry is, and will remain, set.\n rol temp2\n rol\n dex\n bne loopdiv\n beq donediv\ntoosmalldiv\n rol temp2\n rol\n dex\n bne loopdiv\ndonediv\n sta temp1\n lda temp2\n RETURN\n",
   "std_overscan.asm":"drawscreen\n ifconst debugscore\n   ldx #14\n   lda INTIM ; display # cycles left in the score\n\n ifconst mincycles\n lda mincycles \n cmp INTIM\n lda mincycles\n bcc nochange\n lda INTIM\n sta mincycles\nnochange\n endif\n\n;   cmp #$2B\n;   bcs no_cycles_left\n   bmi cycles_left\n   ldx #64\n   eor #$ff ;make negative\ncycles_left\n   stx scorecolor\n   and #$7f ; clear sign bit\n   tax\n   lda scorebcd,x\n   sta score+2\n   lda scorebcd1,x\n   sta score+1\n   jmp done_debugscore   \nscorebcd\n .byte $00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40\n .byte $04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44\n .byte $08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48\n .byte $12, $76, $40, $04, $68, $32, $96, $60, $24, $88\nscorebcd1\n .byte 0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6\n .byte 7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13\n .byte $14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20\n .byte $21, $21, $22, $23, $23, $24, $24, $25, $26, $26\ndone_debugscore\n endif\n\n ifconst debugcycles\n   lda INTIM ; if we go over, it mucks up the background color\n;   cmp #$2B\n;   BCC overscan\n   bmi overscan\n   sta COLUBK\n   bcs doneoverscan\n endif\n\n \noverscan\n lda INTIM ;wait for sync\n bmi overscan\ndoneoverscan\n;do VSYNC\n lda #2\n sta WSYNC\n sta VSYNC\n STA WSYNC\n STA WSYNC\n LDA #0\n STA WSYNC\n STA VSYNC\n sta VBLANK\n ifnconst overscan_time\n lda #37+128\n else\n lda #overscan_time+128\n endif\n sta TIM64T\n\n ifconst legacy\n if legacy < 100\n ldx #4\nadjustloop\n lda player0x,x\n sec\n sbc #14 ;?\n sta player0x,x\n dex\n bpl adjustloop\n endif\n endif\n if (<*)>$F0\n align 256, $EA\n endif\n  sta WSYNC\n  ldx #4\n  SLEEP 3\nHorPosLoop       ;     5\n  lda player0x,X  ;+4   9\n  sec           ;+2  11\nDivideLoop\n  sbc #15\n  bcs DivideLoop;+4  15\n  sta temp1,X    ;+4  19\n  sta RESP0,X   ;+4  23\n  sta WSYNC\n  dex\n  bpl HorPosLoop;+5   5\n                ;     4\n\n  ldx #4\n  ldy temp1,X\n  lda repostable-256,Y\n  sta HMP0,X    ;+14 18\n\n  dex\n  ldy temp1,X\n  lda repostable-256,Y\n  sta HMP0,X    ;+14 32\n\n  dex\n  ldy temp1,X\n  lda repostable-256,Y\n  sta HMP0,X    ;+14 46\n\n  dex\n  ldy temp1,X\n  lda repostable-256,Y\n  sta HMP0,X    ;+14 60\n\n  dex\n  ldy temp1,X\n  lda repostable-256,Y\n  sta HMP0,X    ;+14 74\n\n  sta WSYNC\n \n  sta HMOVE     ;+3   3\n\n\n ifconst legacy\n if legacy < 100\n ldx #4\nadjustloop2\n lda player0x,x\n clc\n adc #14 ;?\n sta player0x,x\n dex\n bpl adjustloop2\n endif\n endif\n\n\n\n\n;set score pointers\n lax score+2\n jsr scorepointerset\n sty scorepointers+5\n stx scorepointers+2\n lax score+1\n jsr scorepointerset\n sty scorepointers+4\n stx scorepointers+1\n lax score\n jsr scorepointerset\n sty scorepointers+3\n stx scorepointers\n\nvblk\n; run possible vblank bB code\n ifconst vblank_bB_code\n   jsr vblank_bB_code\n endif\nvblk2\n LDA INTIM\n bmi vblk2\n jmp kernel\n \n\n    .byte $80,$70,$60,$50,$40,$30,$20,$10,$00\n    .byte $F0,$E0,$D0,$C0,$B0,$A0,$90\nrepostable\n\nscorepointerset\n and #$0F\n asl\n asl\n asl\n adc #<scoretable\n tay \n txa\n; and #$F0\n; lsr\n asr #$F0\n adc #<scoretable\n tax\n rts\n",
   "std_kernel.asm":"; This is a 2-line kernel!\nkernel\n sta WSYNC\n lda #255\n sta TIM64T\n\n lda #1\n sta VDELBL\n sta VDELP0\n ldx ballheight\n inx\n inx\n stx temp4\n lda player1y\n sta temp3\n\n ifconst shakescreen\n   jsr doshakescreen\n else\n   ldx missile0height\n   inx\n endif\n\n inx\n stx stack1\n\n lda bally\n sta stack2\n\n lda player0y\n ldx #0\n sta WSYNC\n stx GRP0\n stx GRP1\n stx PF1\n stx PF2\n stx CXCLR\n ifconst readpaddle\n   stx paddle\n else\n   sleep 3\n endif\n\n sta temp2,x\n\n ;store these so they can be retrieved later\n ifnconst pfres\n   ldx #128-44\n else\n   ldx #132-pfres*4\n endif\n\n inc player1y\n\n lda missile0y\n sta temp5\n lda missile1y\n sta temp6\n\n lda playfieldpos\n sta temp1\n \n ifconst pfrowheight\n lda #pfrowheight+2\n else\n ifnconst pfres\n   lda #10\n else\n   lda #(96/pfres)+2 ; try to come close to the real size\n endif\n endif\n\n clc\n sbc playfieldpos\n sta playfieldpos\n jmp .startkernel\n\n.skipDrawP0\n lda #0\n tay\n jmp .continueP0\n\n.skipDrawP1\n lda #0\n tay\n jmp .continueP1\n\n.kerloop ; enter at cycle 59??\n\ncontinuekernel\n sleep 2\ncontinuekernel2\n lda ballheight\n \n ifconst pfres\n ldy playfield+pfres*4-132,x\n sty PF1 ;3\n ldy playfield+pfres*4-131,x\n sty PF2 ;3\n ldy playfield+pfres*4-129,x\n sty PF1 ; 3 too early?\n ldy playfield+pfres*4-130,x\n sty PF2 ;3\n else\n ldy playfield+44-128,x ;4\n sty PF1 ;3\n ldy playfield+45-128,x ;4\n sty PF2 ;3\n ldy playfield+47-128,x ;4\n sty PF1 ; 3 too early?\n ldy playfield+46-128,x;4\n sty PF2 ;3\n endif\n\n dcp bally\n rol\n rol\n; rol\n; rol\ngoback\n sta ENABL \n.startkernel\n lda player1height ;3\n dcp player1y ;5\n bcc .skipDrawP1 ;2\n ldy player1y ;3\n lda (player1pointer),y ;5; player0pointer must be selected carefully by the compiler\n\t\t\t; so it doesn't cross a page boundary!\n\n.continueP1\n sta GRP1 ;3\n\n ifnconst player1colors\n   lda missile1height ;3\n   dcp missile1y ;5\n   rol;2\n   rol;2\n   sta ENAM1 ;3\n else\n   lda (player1color),y\n   sta COLUP1\n ifnconst playercolors\n   sleep 7\n else\n   lda.w player0colorstore\n   sta COLUP0\n endif\n endif\n\n ifconst pfres\n lda playfield+pfres*4-132,x \n sta PF1 ;3\n lda playfield+pfres*4-131,x \n sta PF2 ;3\n lda playfield+pfres*4-129,x \n sta PF1 ; 3 too early?\n lda playfield+pfres*4-130,x \n sta PF2 ;3\n else\n lda playfield+44-128,x ;4\n sta PF1 ;3\n lda playfield+45-128,x ;4\n sta PF2 ;3\n lda playfield+47-128,x ;4\n sta PF1 ; 3 too early?\n lda playfield+46-128,x;4\n sta PF2 ;3\n endif \n; sleep 3\n\n lda player0height\n dcp player0y\n bcc .skipDrawP0\n ldy player0y\n lda (player0pointer),y\n.continueP0\n sta GRP0\n\n ifnconst no_blank_lines\n ifnconst playercolors\n   lda missile0height ;3\n   dcp missile0y ;5\n   sbc stack1\n   sta ENAM0 ;3\n else\n   lda (player0color),y\n   sta player0colorstore\n   sleep 6\n endif\n   dec temp1\n   bne continuekernel\n else\n   dec temp1\n   beq altkernel2\n ifconst readpaddle\n   ldy currentpaddle\n   lda INPT0,y\n   bpl noreadpaddle\n   inc paddle\n   jmp continuekernel2\nnoreadpaddle\n   sleep 2\n   jmp continuekernel\n else\n ifnconst playercolors \n ifconst PFcolors\n   txa\n   tay\n   lda (pfcolortable),y\n ifnconst backgroundchange\n   sta COLUPF\n else\n   sta COLUBK\n endif\n   jmp continuekernel\n else\n   sleep 12\n endif\n else\n   lda (player0color),y\n   sta player0colorstore\n   sleep 4\n endif\n   jmp continuekernel\n endif\naltkernel2\n   txa\n   sbx #252\n   bmi lastkernelline\n ifconst pfrowheight\n lda #pfrowheight\n else\n ifnconst pfres\n   lda #8\n else\n   lda #(96/pfres) ; try to come close to the real size\n endif\n endif\n   sta temp1\n   jmp continuekernel\n endif\n\naltkernel\n\n ifconst PFmaskvalue\n   lda #PFmaskvalue\n else\n   lda #0\n endif\n sta PF1\n sta PF2\n\n\n ;sleep 3\n\n ;28 cycles to fix things\n ;minus 11=17\n\n; lax temp4\n; clc\n txa\n sbx #252\n\n bmi lastkernelline\n\n ifconst PFcolorandheight\n   ldy playfieldcolorandheight-87,x\n ifnconst backgroundchange\n   sty COLUPF\n else\n   sty COLUBK\n endif\n   lda playfieldcolorandheight-88,x\n   sta.w temp1\n endif\n ifconst PFheights\n   lsr\n   lsr\n   tay\n   lda (pfheighttable),y\n   sta.w temp1\n endif\n ifconst PFcolors\n   tay\n   lda (pfcolortable),y\n ifnconst backgroundchange\n   sta COLUPF\n else\n   sta COLUBK\n endif\n ifconst pfrowheight\n lda #pfrowheight\n else\n ifnconst pfres\n   lda #8\n else\n   lda #(96/pfres) ; try to come close to the real size\n endif\n endif\n   sta temp1\n endif\n ifnconst PFcolorandheight\n ifnconst PFcolors\n ifnconst PFheights\n ifnconst no_blank_lines\n ; read paddle 0\n ; lo-res paddle read\n  ; bit INPT0\n  ; bmi paddleskipread\n  ; inc paddle0\n;donepaddleskip\n   sleep 10\n ifconst pfrowheight\n   lda #pfrowheight\n else\n ifnconst pfres\n   lda #8\n else\n   lda #(96/pfres) ; try to come close to the real size\n endif\n endif\n   sta temp1\n endif\n endif\n endif\n endif\n \n\n lda ballheight\n dcp bally\n sbc temp4\n\n\n jmp goback\n\n\n ifnconst no_blank_lines\nlastkernelline\n ifnconst PFcolors\n   sleep 10\n else\n   ldy #124\n   lda (pfcolortable),y\n   sta COLUPF\n endif\n\n ifconst PFheights\n ldx #1\n sleep 4\n else\n ldx playfieldpos\n sleep 3\n endif\n\n jmp enterlastkernel\n\n else\nlastkernelline\n \n ifconst PFheights\n ldx #1\n sleep 5\n else\n   ldx playfieldpos\n sleep 4\n endif\n\n   cpx #1\n   bne .enterfromNBL\n   jmp no_blank_lines_bailout\n endif\n\n if ((<*)>$d5)\n align 256\n endif\n ; this is a kludge to prevent page wrapping - fix!!!\n\n.skipDrawlastP1\n sleep 2\n lda #0\n jmp .continuelastP1\n\n.endkerloop ; enter at cycle 59??\n \n nop\n\n.enterfromNBL\n ifconst pfres\n ldy.w playfield+pfres*4-4\n sty PF1 ;3\n ldy.w playfield+pfres*4-3\n sty PF2 ;3\n ldy.w playfield+pfres*4-1\n sty PF1 ; possibly too early?\n ldy.w playfield+pfres*4-2\n sty PF2 ;3\n else\n ldy.w playfield+44\n sty PF1 ;3\n ldy.w playfield+45\n sty PF2 ;3\n ldy.w playfield+47\n sty PF1 ; possibly too early?\n ldy.w playfield+46\n sty PF2 ;3\n endif\n\nenterlastkernel\n lda ballheight\n\n; tya\n dcp bally\n; sleep 4\n\n; sbc stack3\n rol\n rol\n sta ENABL \n\n lda player1height ;3\n dcp player1y ;5\n bcc .skipDrawlastP1\n ldy player1y ;3\n lda (player1pointer),y ;5; player0pointer must be selected carefully by the compiler\n\t\t\t; so it doesn't cross a page boundary!\n\n.continuelastP1\n sta GRP1 ;3\n\n ifnconst player1colors\n   lda missile1height ;3\n   dcp missile1y ;5\n else\n   lda (player1color),y\n   sta COLUP1\n endif\n\n dex\n ;dec temp4 ; might try putting this above PF writes\n beq endkernel\n\n\n ifconst pfres\n ldy.w playfield+pfres*4-4\n sty PF1 ;3\n ldy.w playfield+pfres*4-3\n sty PF2 ;3\n ldy.w playfield+pfres*4-1\n sty PF1 ; possibly too early?\n ldy.w playfield+pfres*4-2\n sty PF2 ;3\n else\n ldy.w playfield+44\n sty PF1 ;3\n ldy.w playfield+45\n sty PF2 ;3\n ldy.w playfield+47\n sty PF1 ; possibly too early?\n ldy.w playfield+46\n sty PF2 ;3\n endif\n\n ifnconst player1colors\n   rol;2\n   rol;2\n   sta ENAM1 ;3\n else\n ifnconst playercolors\n   sleep 7\n else\n   lda.w player0colorstore\n   sta COLUP0\n endif\n endif\n \n lda.w player0height\n dcp player0y\n bcc .skipDrawlastP0\n ldy player0y\n lda (player0pointer),y\n.continuelastP0\n sta GRP0\n\n\n\n ifnconst no_blank_lines\n   lda missile0height ;3\n   dcp missile0y ;5\n   sbc stack1\n   sta ENAM0 ;3\n   jmp .endkerloop\n else\n ifconst readpaddle\n   ldy currentpaddle\n   lda INPT0,y\n   bpl noreadpaddle2\n   inc paddle\n   jmp .endkerloop\nnoreadpaddle2\n   sleep 4\n   jmp .endkerloop\n else ; no_blank_lines and no paddle reading\n sleep 14\n jmp .endkerloop\n endif\n endif\n\n\n;  ifconst donepaddleskip\n;paddleskipread\n ; this is kind of lame, since it requires 4 cycles from a page boundary crossing\n ; plus we get a lo-res paddle read\n; bmi donepaddleskip\n;  endif\n\n.skipDrawlastP0\n sleep 2\n lda #0\n jmp .continuelastP0\n\n ifconst no_blank_lines\nno_blank_lines_bailout\n ldx #0\n endif\n\nendkernel\n ; 6 digit score routine\n stx PF1\n stx PF2\n stx PF0\n clc\n\n ifconst pfrowheight\n lda #pfrowheight+2\n else\n ifnconst pfres\n   lda #10\n else\n   lda #(96/pfres)+2 ; try to come close to the real size\n endif\n endif\n\n sbc playfieldpos\n sta playfieldpos\n txa\n\n ifconst shakescreen\n   bit shakescreen\n   bmi noshakescreen2\n   ldx #$3D\nnoshakescreen2\n endif\n\n   sta WSYNC,x\n\n;                STA WSYNC ;first one, need one more\n sta REFP0\n sta REFP1\n                STA GRP0\n                STA GRP1\n ;               STA PF1\n   ;             STA PF2\n sta HMCLR\n sta ENAM0\n sta ENAM1\n sta ENABL\n\n lda temp2 ;restore variables that were obliterated by kernel\n sta player0y\n lda temp3\n sta player1y\n ifnconst player1colors\n   lda temp6\n   sta missile1y\n endif\n ifnconst playercolors\n ifnconst readpaddle\n   lda temp5\n   sta missile0y\n endif\n endif\n lda stack2\n sta bally\n\n ifconst no_blank_lines\n sta WSYNC\n endif\n\n lda INTIM\n clc\n ifnconst vblank_time\n adc #43+12+87\n else\n adc #vblank_time+12+87\n endif\n; sta WSYNC\n sta TIM64T\n\n ifconst minikernel\n jsr minikernel\n endif\n\n ; now reassign temp vars for score pointers\n\n; score pointers contain:\n; score1-5: lo1,lo2,lo3,lo4,lo5,lo6\n; swap lo2->temp1\n; swap lo4->temp3\n; swap lo6->temp5\n ifnconst noscore\n lda scorepointers+1\n; ldy temp1\n sta temp1\n; sty scorepointers+1\n\n lda scorepointers+3\n; ldy temp3\n sta temp3\n; sty scorepointers+3\n\n\n sta HMCLR\n tsx\n stx stack1 \n ldx #$10\n stx HMP0\n\n sta WSYNC\n ldx #0\n                STx GRP0\n                STx GRP1 ; seems to be needed because of vdel\n\n lda scorepointers+5\n; ldy temp5\n sta temp5,x\n; sty scorepointers+5\n lda #>scoretable\n sta scorepointers+1\n sta scorepointers+3\n sta scorepointers+5,x\n sta temp2,x\n sta temp4,x\n sta temp6,x\n                LDY #7\n                STA RESP0\n                STA RESP1\n\n\n        LDA #$03\n        STA NUSIZ0\n        STA NUSIZ1,x\n        STA VDELP0\n        STA VDELP1\n        LDA #$20\n        STA HMP1\n               LDA scorecolor \n;               STA HMCLR\n;               STA WSYNC; second one\n                STA HMOVE ; cycle 73 ?\n\n                STA COLUP0\n                STA COLUP1\n lda  (scorepointers),y\n sta  GRP0\n ifconst pfscore\n lda pfscorecolor\n sta COLUPF\n endif\n lda  (scorepointers+8),y\n sta WSYNC\n sleep 2\n jmp beginscore\n\n if ((<*)>$d4)\n align 256 ; kludge that potentially wastes space!  should be fixed!\n endif\n\nloop2\n lda  (scorepointers),y     ;+5  68  204\n sta  GRP0            ;+3  71  213      D1     --      --     --\n ifconst pfscore\n lda.w pfscore1\n sta PF1\n else\n sleep 7\n endif\n ; cycle 0\n lda  (scorepointers+$8),y  ;+5   5   15\nbeginscore\n sta  GRP1            ;+3   8   24      D1     D1      D2     --\n lda  (scorepointers+$6),y  ;+5  13   39\n sta  GRP0            ;+3  16   48      D3     D1      D2     D2\n lax  (scorepointers+$2),y  ;+5  29   87\n txs\n lax  (scorepointers+$4),y  ;+5  36  108\n sleep 3\n\n ifconst pfscore\n lda pfscore2\n sta PF1\n else\n sleep 6\n endif\n\n lda  (scorepointers+$A),y  ;+5  21   63\n stx  GRP1            ;+3  44  132      D3     D3      D4     D2!\n tsx\n stx  GRP0            ;+3  47  141      D5     D3!     D4     D4\n sta  GRP1            ;+3  50  150      D5     D5      D6     D4!\n sty  GRP0            ;+3  53  159      D4*    D5!     D6     D6\n dey\n bpl  loop2           ;+2  60  180\n\n ldx stack1 \n txs\n; lda scorepointers+1\n ldy temp1\n; sta temp1\n sty scorepointers+1\n\n                LDA #0   \n sta PF1\n               STA GRP0\n                STA GRP1\n        STA VDELP0\n        STA VDELP1;do we need these\n        STA NUSIZ0\n        STA NUSIZ1\n\n; lda scorepointers+3\n ldy temp3\n; sta temp3\n sty scorepointers+3\n\n; lda scorepointers+5\n ldy temp5\n; sta temp5\n sty scorepointers+5\n endif ;noscore\n LDA #%11000010\n sta WSYNC\n STA VBLANK\n RETURN\n\n ifconst shakescreen\ndoshakescreen\n   bit shakescreen\n   bmi noshakescreen\n   sta WSYNC\nnoshakescreen\n   ldx missile0height\n   inx\n   rts\n endif\n\n",
   "2600basic.h":" processor 6502\n include \"vcs.h\"\n include \"macro.h\"\n include \"2600basic_variable_redefs.h\"\n\nplayer0x = $80\nplayer1x = $81\nmissile0x = $82\nmissile1x = $83\nballx = $84\n\nobjecty = $85\nplayer0y = $85\nplayer1y = $86\nmissile1height = $87\nmissile1y = $88\nbally = $89\n\nplayer1color = $87 ; replaces missile 1\n\nplayer0pointer = $8A ;uses $8A-$8B\nplayer0pointerlo = $8A\nplayer0pointerhi = $8B\nplayer1pointer = $8C ; $8C-$8D\nplayer1pointerlo = $8C\nplayer1pointerhi = $8D\n\nplayer0height = $8E\nplayer1height = $8F\nmissile0height = $90\nmissile0y = $91\nballheight = $92\n\ncurrentpaddle = $90 ; replaces missile 0 (and can't be used with playercolor)\npaddle = $91 ; replaces missile 0\nplayer0colorstore = $82 ; replaces missile 0\nplayer0color = $90 ; replaces missile 0\n\nscore = $93 ; $93-$95\nscorepointers = $96 ; $96-$9B = 6 bytes\ntemp1 = $9C ;used by kernel.  can be used in program too, but\ntemp2 = $9D ;are obliterated when drawscreen is called.\ntemp3 = $9E\ntemp4 = $9F\ntemp5 = $A0\ntemp6 = $A1\n\nrand = $A2\nscorecolor = $A3\n\nvar0 = $A4\nvar1 = $A5\nvar2 = $A6\nvar3 = $A7\nvar4 = $A8\nvar5 = $A9\nvar6 = $AA\nvar7 = $AB\nvar8 = $AC\nvar9 = $AD\nvar10 = $AE\nvar11 = $AF\nvar12 = $B0\nvar13 = $B1\nvar14 = $B2\nvar15 = $B3\nvar16 = $B4\nvar17 = $B5\nvar18 = $B6\nvar19 = $B7\nvar20 = $B8\nvar21 = $B9\nvar22 = $BA\nvar23 = $BB\nvar24 = $BC\nvar25 = $BD\nvar26 = $BE\nvar27 = $BF\nvar28 = $C0\nvar29 = $C1\nvar30 = $C2\nvar31 = $C3\nvar32 = $C4\nvar33 = $C5\nvar34 = $C6\nvar35 = $C7\nvar36 = $C8\nvar37 = $C9\nvar38 = $CA\nvar39 = $CB\nvar40 = $CC\nvar41 = $CD\nvar42 = $CE\nvar43 = $CF\nvar44 = $D0\nvar45 = $D1\nvar46 = $D2\nvar47 = $D3\n\ntemp7 = $D4 ; This is used to aid in bankswitching\n\nplayfieldpos = $D5\n\nA = $d6\na = $d6\nB = $d7\nb = $d7\nC = $d8\nc = $d8\nD = $d9\nd = $d9\nE = $da\ne = $da\nF = $db\nf = $db\nG = $dc\ng = $dc\nH = $dd\nh = $dd\nI = $de\ni = $de\nJ = $df\nj = $df\nK = $e0\nk = $e0\nL = $e1\nl = $e1\nM = $e2\nm = $e2\nN = $e3\nn = $e3\nO = $e4\no = $e4\nP = $e5\np = $e5\nQ = $e6\nq = $e6\nR = $e7\nr = $e7\nS = $e8\ns = $e8\nT = $e9\nt = $e9\nU = $ea\nu = $ea\nV = $eb\nv = $eb\nW = $ec\nw = $ec\nX = $ed\nx = $ed\nY = $ee\ny = $ee\nZ = $ef\nz = $ef\n\n; available for other uses, or if unused, provide more stack space\n\naux1 = $f0\naux2 = $f1\naux3 = $f2\naux4 = $f3\naux5 = $f4\naux6 = $f5\n\n; playfield color/height pointers\npfcolortable = $f0 ; and $d5\npfheighttable = $f0 ; and $d5\n; the above pointers are the same because if color and height are both used together,\n; they must used absolute indexed and cannot use pointers\n\nlifepointer = $f2 ; pointer to \"lives\" shape\n; upper 3 bits of $f2 contain the number of lives\nlifecolor = $f4\nlives = $f3 ; # lives >> 5\nstatusbarlength = $f5 ; only uses upper 5 bits; other bits free\n\npfscore1 = $f2 ; optional playfield bytes in score\npfscore2 = $f3\npfscorecolor = $f4\n\nstack1 = $f6\nstack2 = $f7\nstack3 = $f8\nstack4 = $f9\n; the stack bytes above may be used in the kernel\n; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF\n\n MAC RETURN\t; auto-return from either a regular or bankswitched module\n   ifnconst bankswitch\n     rts\n   else\n     jmp BS_return\n   endif\n ENDM\n\n ifconst superchip\nplayfieldbase = $10D0\n else\nplayfieldbase = $A4\n endif\n\n; define playfield start based on height\n ifnconst pfres\nplayfield = playfieldbase\n else\nplayfield = playfieldbase-(pfres-12)*4\n endif\n\n",
   "banksw.asm":"; every bank has this stuff at the same place\n; this code can switch to/from any bank at any entry point\n; and can preserve register values\n; note: lines not starting with a space are not placed in all banks\n;\n; line below tells the compiler how long this is - do not remove\n;size=32\nbegin_bscode\n ldx #$ff\n txs\n lda #>(start-1)\n pha\n lda #<(start-1)\n pha\nBS_return\n pha\n txa\n pha\n tsx\n lda 4,x ; get high byte of return address\n rol   \n rol\n rol\n rol\n and #bs_mask ;1 3 or 7 for F8/F6/F4\n tax\n inx\nBS_jsr\n lda bankswitch_hotspot-1,x\n pla\n tax\n pla\n rts\n if ((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))\n   echo \"WARNING: size parameter in banksw.asm too small - the program probably will not work.\"\n   echo \"Change to\",[(*-begin_bscode+1)&$FF]d,\"and try again.\"\n endif\n",
   "multispriteheader.asm":" processor 6502\n include \"vcs.h\"\n include \"macro.h\"\n include \"multisprite.h\"\n include \"2600basic_variable_redefs.h\"\n ifconst bankswitch\n  if bankswitch == 8\n     ORG $1000\n     RORG $D000\n  endif\n  if bankswitch == 16\n     ORG $1000\n     RORG $9000\n  endif\n  if bankswitch == 32\n     ORG $1000\n     RORG $1000\n  endif\n else\n   ORG $F000\n endif\n",
   "div_mul.asm":"; y and a contain multiplicands, result in a\n\nmul8\n sty temp1\n sta temp2\n lda #0\nreptmul8\n lsr temp2\n bcc skipmul8\n clc\n adc temp1\n;bcs donemul8 might save cycles?\nskipmul8\n;beq donemul8 might save cycles?\n asl temp1\n bne reptmul8\ndonemul8\n RETURN\n\ndiv8\n ; a=numerator y=denominator, result in a\n cpy #2\n bcc div8end+1;div by 0 = bad, div by 1=no calc needed, so bail out\n sty temp1\n ldy #$ff\ndiv8loop\n sbc temp1\n iny\n bcs div8loop\ndiv8end\n tya\n ; result in a\n RETURN\n",
   "6lives_statusbar.asm":"minikernel ; display up to 6 lives on screen\n sta WSYNC\n ldx #$20\n stx HMP1\n stx VDELP0\n lda lives\n lsr\n lsr\n lsr\n lsr\n lsr\n sta RESP0\n sta RESP1\n stx VDELP1\n tax\n lda lifenusiz0table,x\n sta NUSIZ0\n lda lifenusiz1table,x\n sta NUSIZ1\n lda lifecolor\n sta COLUP0\n sta COLUP1\n lda #$10\n sta HMP0\n\n lda statusbarlength\n lsr\n lsr\n lsr ; 0-31\n ; 3 cases: 0-7, 8-15, 16-24\n ; if 0-7, temp1=val, temp2=0, temp3=0\n ; if 8-15, temp1=255, temp2=val (rev), temp3=0\n ; if 16-23, temp1=255, temp2=255, temp3=val\n tay\n\n sta HMOVE ;cycle 74?\n\n ifconst statusbarcolor\n ; only write COLUPF if color variable exists, otherwise use existing PF color\n lda statusbarcolor\n sta COLUPF\n endif\n\n cmp #8\n bcc zero_7\n cmp #16\n bcc eight_15\n lda #255\n sta temp1\n sta temp2\n lda statustable-16,y\n sta temp3\n lda statustable,y\n sta temp4\n jmp startlifedisplay\n \nzero_7\n lda #0\n sta temp4\n sta temp3\n sta temp2\n lda statustable,y\n sta temp1\n jmp startlifedisplay\neight_15\n lda #255\n sta temp1\n lda #0\n sta temp4\n sta temp3\n lda statustable+16,y\n sta temp2\nstartlifedisplay\n ldy #7\nlifeloop\n sta WSYNC\n stx PF0\n lda (lifepointer),y\n cpx #0\n bne onelife\n .byte $0C\nonelife\n sta GRP0\n\n cpx #2\n bcs nolives\n .byte $0C\nnolives\n sta GRP1\n lda temp4\n sta PF0\n lda temp1\n sta PF2\n lda temp3\n sta PF1\n lda temp2\n sta PF2 ;cycle 48!\n sleep 14\n lda #0\n dey\n sta PF1\n bpl lifeloop\n sta WSYNC\n iny\n sty PF0\n sty PF2\n sty PF1\n sty GRP0\n sty GRP1\n rts\n\n if (<*) > $F5\n align 256\n endif\nlifenusiz1table\n .byte 0\nlifenusiz0table\n .byte 0,0,0,1,1,3,3,3\n\nstatustable\n;0-7 and 16+\n .byte %00000000\n .byte %00000001\n .byte %00000011\n .byte %00000111\n .byte %00001111\n .byte %00011111\n .byte %00111111\n .byte %01111111\n .byte 255\n .byte 255\n .byte 255\n .byte 255\n .byte 255\n .byte 255\n .byte 255\n .byte 255\n; 8-15\n .byte 0\n .byte 0\n .byte 0\n .byte 0\n .byte 0\n .byte 0\n .byte 0\n .byte 0\n .byte %00000000\n .byte %10000000\n .byte %11000000\n .byte %11100000\n .byte %11110000\n .byte %11111000\n .byte %11111100\n .byte %11111110\n\n",
   "multisprite_kernel.asm":"FineAdjustTableBegin\n\t.byte %01100000\t\t;left 6\n\t.byte %01010000\n\t.byte %01000000\n\t.byte %00110000\n\t.byte %00100000\n\t.byte %00010000\n\t.byte %00000000\t\t;left 0\n\t.byte %11110000\n\t.byte %11100000\n\t.byte %11010000\n\t.byte %11000000\n\t.byte %10110000\n\t.byte %10100000\n\t.byte %10010000\n\t.byte %10000000\t\t;right 8\nFineAdjustTableEnd\t=\tFineAdjustTableBegin - 241\n\nPFStart\n .byte 87,43,0,21,0,0,0,10\nblank_pf\n .byte 0,0,0,0,0,0,0,5\n; .byte 43,21,0,10,0,0,0,5\n ifconst screenheight\npfsub\n .byte 8,4,2,2,1,0,0,1,0\n endif\n\t;--set initial P1 positions\nmultisprite_setup\n lda #15\n sta pfheight\n\n\tldx #4\n; stx temp3\nSetCopyHeight\n;\tlda #76\n;\tsta NewSpriteX,X\n;\tlda CopyColorData,X\n;\tsta NewCOLUP1,X\n ;lda SpriteHeightTable,X\n; sta spriteheight,x\n\ttxa\n\tsta SpriteGfxIndex,X\n\tsta spritesort,X\n\tdex\n\tbpl SetCopyHeight\n\n\n\n; since we can't turn off pf, point PF to zeros here\n lda #>blank_pf\n sta PF2pointer+1\n sta PF1pointer+1\n lda #<blank_pf\n sta PF2pointer\n sta PF1pointer\n rts\n\ndrawscreen\n ifconst debugscore\n jsr debugcycles\n endif\n\nWaitForOverscanEnd\n\tlda INTIM\n\tbmi WaitForOverscanEnd\n\n\tlda #2\n\tsta WSYNC\n\tsta VSYNC\n\tsta WSYNC\n\tsta WSYNC\n\tlsr\n\tsta VDELBL\n\tsta VDELP0\n\tsta WSYNC\n\tsta VSYNC\t;turn off VSYNC\n      ifconst overscan_time\n        lda #overscan_time+5+128\n      else\n\tlda #42+128\n      endif\n\tsta TIM64T\n\n \tjsr setscorepointers\n\tjsr SetupP1Subroutine\n\n\t;-------------\n\n\n\n\n\n\t;--position P0, M0, M1, BL\n\n\tjsr PrePositionAllObjects\n\n\t;--set up player 0 pointer\n\n\tlda player0pointer ; player0: must be run every frame!\n\tsec\n\tsbc player0y\n\tclc\n\tadc player0height\n\tsta player0pointer\n\n\tlda player0y\n\tsta P0Top\n\tsec\n\tsbc player0height\n\tclc\n\tadc #$80\n\tsta P0Bottom\n\t\n\n\t;--some final setup\n\n ldx #4\n lda #$80\ncycle74_HMCLR\n sta HMP0,X\n dex\n bpl cycle74_HMCLR\n;\tsta HMCLR\n\n\n\tlda #0\n\tsta PF1\n\tsta PF2\n\tsta GRP0\n\tsta GRP1\n\n\n\tjsr KernelSetupSubroutine\n\n; run possible vblank bB code\n ifconst vblank_bB_code\n   jsr vblank_bB_code\n endif\n\nWaitForVblankEnd\n\tlda INTIM\n\tbmi WaitForVblankEnd\n        lda #0\n\tsta WSYNC\n\tsta VBLANK\t;turn off VBLANK - it was turned on by overscan\n\tsta CXCLR\n\n\n\tjmp KernelRoutine\n\n\nPositionASpriteSubroutine\t;call this function with A == horizontal position (0-159)\n\t\t\t\t;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)\n\t\t\t\t;if you do not wish to write to P1 during this function, make\n\t\t\t\t;sure Y==0 before you call it.  This function will change Y, and A\n\t\t\t\t;will be the value put into HMxx when returned.\n\t\t\t\t;Call this function with at least 11 cycles left in the scanline \n\t\t\t\t;(jsr + sec + sta WSYNC = 11); it will return 9 cycles\n\t\t\t\t;into the second scanline\n\tsec\n\tsta WSYNC\t\t\t;begin line 1\n\tsta.w HMCLR\t\t\t;+4\t 4\nDivideBy15Loop\n\tsbc #15\n\tbcs DivideBy15Loop\t\t\t;+4/5\t8/13.../58\n\n\ttay\t\t\t\t;+2\t10/15/...60\n\tlda FineAdjustTableEnd,Y\t;+5\t15/20/...65\n\n\t\t\t;\t15\n\tsta HMP0,X\t;+4\t19/24/...69\n\tsta RESP0,X\t;+4\t23/28/33/38/43/48/53/58/63/68/73\n\tsta WSYNC\t;+3\t 0\tbegin line 2\n\tsta HMOVE\t;+3\n\trts\t\t;+6\t 9\n\n;-------------------------------------------------------------------------\n\nPrePositionAllObjects\n\n\tldx #4\n\tlda ballx\n\tjsr PositionASpriteSubroutine\n\t\n\tdex\n\tlda missile1x\n\tjsr PositionASpriteSubroutine\n\t\n\tdex\n\tlda missile0x\n\tjsr PositionASpriteSubroutine\n\n\tdex\n\tdex\n\tlda player0x\n\tjsr PositionASpriteSubroutine\n\n\trts\n\n\n;-------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n;-------------------------------------------------------------------------\n\n\nKernelSetupSubroutine\n\n\tldx #4\nAdjustYValuesUpLoop\n\tlda NewSpriteY,X\n\tclc\n\tadc #2\n\tsta NewSpriteY,X\n\tdex\n\tbpl AdjustYValuesUpLoop\n\n\n\tldx temp3 ; first sprite displayed\n\n\tlda SpriteGfxIndex,x\n\ttay\n\tlda NewSpriteY,y\n\tsta RepoLine\n\n\tlda SpriteGfxIndex-1,x\n\ttay\n\tlda NewSpriteY,y\n\tsta temp6\n\n\tstx SpriteIndex\n\n\n\n\tlda #255\n\tsta P1Bottom\n\n\tlda player0y\n ifconst screenheight\n\tcmp #screenheight+1\n else\n\tcmp #$59\n endif\n\tbcc nottoohigh\n\tlda P0Bottom\n\tsta P0Top\t\t\n\n       \n\nnottoohigh\n\trts\n\n;-------------------------------------------------------------------------\n\n\n\n\n\n;*************************************************************************\n\n;-------------------------------------------------------------------------\n;-------------------------Data Below--------------------------------------\n;-------------------------------------------------------------------------\n\nMaskTable\n\t.byte 1,3,7,15,31\n\n ; shove 6-digit score routine here\n\nsixdigscore\n\tlda #0\n;\tsta COLUBK\n\tsta PF0\n\tsta PF1\n\tsta PF2\n\tsta ENABL\n\tsta ENAM0\n\tsta ENAM1\n\t;end of kernel here\n\n\n ; 6 digit score routine\n; lda #0\n; sta PF1\n; sta PF2\n; tax\n\n   sta WSYNC;,x\n\n;                STA WSYNC ;first one, need one more\n sta REFP0\n sta REFP1\n                STA GRP0\n                STA GRP1\n sta HMCLR\n\n ; restore P0pointer\n\n\tlda player0pointer\n\tclc\n\tadc player0y\n\tsec\n\tsbc player0height\n\tsta player0pointer\n\n ifconst vblank_time\n ifconst screenheight\n if screenheight == 84\n\tlda  #vblank_time+9+128+10\n else\n\tlda  #vblank_time+9+128+19\n endif\n else\n\tlda  #vblank_time+9+128\n endif\n else\n ifconst screenheight\n if screenheight == 84\n\tlda  #52+128+10\n else\n\tlda  #52+128+19\n endif\n else\n\tlda  #52+128\n endif\n endif\n\n\tsta  TIM64T\n ifconst minikernel\n jsr minikernel\n endif\n ifconst noscore\n jmp skipscore\n endif\n\n; score pointers contain:\n; score1-5: lo1,lo2,lo3,lo4,lo5,lo6\n; swap lo2->temp1\n; swap lo4->temp3\n; swap lo6->temp5\n\n lda scorepointers+5\n sta temp5\n lda scorepointers+1\n sta temp1\n lda scorepointers+3\n sta temp3\n\n lda #>scoretable\n sta scorepointers+1\n sta scorepointers+3\n sta scorepointers+5\n sta temp2\n sta temp4\n sta temp6\n\n rts\n\n\n\n;-------------------------------------------------------------------------\n;----------------------Kernel Routine-------------------------------------\n;-------------------------------------------------------------------------\n\n\n;-------------------------------------------------------------------------\n; echo *\n; repeat $f147-*\n; brk\n; repend\n;\torg $F240\n\nSwitchDrawP0K1\t\t\t\t;\t72\n\tlda P0Bottom\n\tsta P0Top\t\t\t;+6\t 2\n\tjmp BackFromSwitchDrawP0K1\t;+3\t 5\n\nWaitDrawP0K1\t\t\t\t;\t74\n\tSLEEP 4\t\t\t\t;+4\t 2\n\tjmp BackFromSwitchDrawP0K1\t;+3\t 5\n\nSkipDrawP1K1\t\t\t\t;\t11\n\tlda #0\n\tsta GRP1\t\t\t;+5\t16\tso Ball gets drawn\n\tjmp BackFromSkipDrawP1\t\t;+3\t19\n\n;-------------------------------------------------------------------------\n\nKernelRoutine\n ifnconst screenheight\n jsr wastetime ; waste 12 cycles\n else\n sleep 6\n endif\n\ttsx\n\tstx stack1\n\tldx #ENABL\n\ttxs\t\t\t;+9\t 9\n\n ldx #0\n lda pfheight\n bpl asdhj\n .byte $24\nasdhj\n tax\n\n; ldx pfheight\n lda PFStart,x ; get pf pixel resolution for heights 15,7,3,1,0\n\n ifconst screenheight\n  sec\n if screenheight == 84\n  sbc pfsub+1,x\n else\n  sbc pfsub,x\n endif\n endif\n \n sta pfpixelheight\n\n ifconst screenheight\n        ldy #screenheight\n else\n\tldy #88\n endif\n \n;\tlda #$02\n;\tsta COLUBK\t\t;+5\t18\n\n; sleep 25\n sleep 2\nKernelLoopa\t\t\t;\t50\n\tSLEEP 7\t\t\t;+4\t54\nKernelLoopb\t\t\t;\t54\n\tSLEEP 2\t\t;+12\t66\n\tcpy P0Top\t\t;+3\t69\n\tbeq SwitchDrawP0K1\t;+2\t71\n\tbpl WaitDrawP0K1\t;+2\t73\n\tlda (player0pointer),Y\t;+5\t 2\n\tsta GRP0\t\t;+3\t 5\tVDEL because of repokernel\nBackFromSwitchDrawP0K1\n\n\tcpy P1Bottom\t\t;+3\t 8\tunless we mean to draw immediately, this should be set\n\t\t\t\t;\t\tto a value greater than maximum Y value initially\n\tbcc SkipDrawP1K1\t;+2\t10\n\tlda (P1display),Y\t;+5\t15\n\tsta.w GRP1\t\t;+4\t19\nBackFromSkipDrawP1\n\n;fuck\t\n sty temp1\n ldy pfpixelheight\n\tlax (PF1pointer),y\n\tstx PF1\t\t\t;+7\t26\n\tlda (PF2pointer),y\n\tsta PF2\t\t\t;+7\t33\n ;sleep 6\n\tstx PF1temp2\n\tsta PF2temp2\n\tdey\n\tlda (PF1pointer),y\n\tsta PF1temp1\n\tlda (PF2pointer),y\n\tsta PF2temp1\n ldy temp1\n\n ldx #ENABL\n txs\n\tcpy bally\n\tphp\t\t\t;+6\t39\tVDEL ball\n\n\n\tcpy missile1y\n\tphp\t\t\t;+6\t71\n\n\tcpy missile0y\n\tphp\t\t\t;+6\t 1\n ldx #1\n\t\n\n\tdey\t\t\t;+2\t15\n\n\tcpy RepoLine\t\t;+3\t18\n\tbeq RepoKernel\t\t;+2\t20\n;\tSLEEP 20\t\t;+23\t43\n sleep 6\n\nnewrepo ; since we have time here, store next repoline\n ldx SpriteIndex\n lda SpriteGfxIndex-1,x\n tax\n lda NewSpriteY,x\n sta temp6\n sleep 4 \n\nBackFromRepoKernel\n\ttya\t\t\t;+2\t45\n\tand pfheight\t\t\t;+2\t47\n\tbne KernelLoopa\t\t;+2\t49\n\tdec pfpixelheight\n\tbpl KernelLoopb\t\t;+3\t54\n;\tbmi donewkernel\t\t;+3\t54\n;\tbne KernelLoopb+1\t\t;+3\t54\n\ndonewkernel\n\tjmp DoneWithKernel\t;+3\t56\n\n;-------------------------------------------------------------------------\n \n ; room here for score?\n\nsetscorepointers\n lax score+2\n jsr scorepointerset\n sty scorepointers+5\n stx scorepointers+2\n lax score+1\n jsr scorepointerset\n sty scorepointers+4\n stx scorepointers+1\n lax score\n jsr scorepointerset\n sty scorepointers+3\n stx scorepointers\nwastetime\n rts\n\nscorepointerset\n and #$0F\n asl\n asl\n asl\n adc #<scoretable\n tay\n txa\n and #$F0\n lsr\n adc #<scoretable\n tax\n rts\n;\talign 256\n\nSwitchDrawP0KR\t\t\t\t;\t45\n\tlda P0Bottom\n\tsta P0Top\t\t\t;+6\t51\n\tjmp BackFromSwitchDrawP0KR\t;+3\t54\n\nWaitDrawP0KR\t\t\t\t;\t47\n\tSLEEP 4\t\t\t\t;+4\t51\n\tjmp BackFromSwitchDrawP0KR\t;+3\t54\n\n;-----------------------------------------------------------\n\nnoUpdateXKR\n sleep 3\n JMP retXKR\n\nskipthis\n ldx #1\n; sleep 2\n jmp goback\n\nRepoKernel\t\t\t;\t22\tcrosses page boundary\n\ttya\n\tand pfheight\t\t\t;+2\t26\n\tbne noUpdateXKR\t\t;+2\t28\n\tdex\t\t\t;+2\t30\n\tdec pfpixelheight\n;\tstx Temp\t\t;+3\t35\n;\tSLEEP 3\nretXKR\n\n\tcpy P0Top\t\t;+3\t42\n\tbeq SwitchDrawP0KR\t;+2\t44\n\tbpl WaitDrawP0KR\t;+2\t46\n\tlda (player0pointer),Y\t;+5\t51\n\tsta GRP0\t\t;+3\t54\tVDEL\nBackFromSwitchDrawP0KR\n\tsec\t\t\t;+2\t56\n \n\n\n\tlda PF2temp1,X\n\tldy PF1temp1,X\n\n\tldx SpriteIndex\t;+3\t 2\n\n\tsta PF2\t\t\t;+7\t63\n\n\tlda SpriteGfxIndex,x\n\tsty PF1\t\t\t;+7\t70\ttoo early?\n\ttax\n\tlda #0\n\tsta GRP1\t\t;+5\t75\tto display player 0\n\tlda NewSpriteX,X\t;+4\t 6\n \nDivideBy15LoopK\t\t\t\t;\t 6\t(carry set above)\n\tsbc #15\n\tbcs DivideBy15LoopK\t\t;+4/5\t10/15.../60\n\n\ttax\t\t\t\t;+2\t12/17/...62\n\tlda FineAdjustTableEnd,X\t;+5\t17/22/...67\n\n\tsta HMP1\t\t\t;+3\t20/25/...70\n\tsta RESP1\t\t\t;+3\t23/28/33/38/43/48/53/58/63/68/73\n\tsta WSYNC\t\t\t;+3\t 0\tbegin line 2\n\t;sta HMOVE\t\t\t;+3\t 3\n\n\tldx #ENABL\n\ttxs\t\t\t;+4\t25\n\tldy RepoLine ; restore y\n\tcpy bally\n\tphp\t\t\t;+6\t 9\tVDEL ball\n\n\tcpy missile1y\n\tphp\t\t\t;+6\t15\n\n\tcpy missile0y\n\tphp\t\t\t;+6\t21\n\t\n\n \n\n\n;15 cycles\n\ttya\n\tand pfheight\n ;eor #1\n\tand #$FE\n\tbne skipthis\n tax\n sleep 4\n;\tsleep 2\ngoback\n\n\tdey\n\tcpy P0Top\t\t\t;+3\t52\n\tbeq SwitchDrawP0KV\t;+2\t54\n\tbpl WaitDrawP0KV\t\t;+2\t56\n\tlda (player0pointer),Y\t\t;+5\t61\n\tsta GRP0\t\t\t;+3\t64\tVDEL\nBackFromSwitchDrawP0KV\n\n; sleep 3\n\n\tlda PF2temp1,X\n\tsta PF2\t\t\t;+7\t 5\n\tlda PF1temp1,X\n\tsta PF1\t\t\t;+7\t74 \n sta HMOVE\n\n\tlda #0\n\tsta GRP1\t\t\t;+5\t10\tto display GRP0\n\n\tldx #ENABL\n\ttxs\t\t\t;+4\t 8\n\n\tldx SpriteIndex\t;+3\t13\trestore index into new sprite vars\n\t;--now, set all new variables and return to main kernel loop\n\n\n;\n\tlda SpriteGfxIndex,X\t;+4\t31\n\ttax\t\t\t\t;+2\t33\n;\n\tlda NewSpriteY,X\t\t;+4\t46\n\tsta P1Bottom\t\t;+3\t49\tadjust for height below\n\n\n\n\tlda NewNUSIZ,X\n\tsta NUSIZ1\t\t\t;+7\t20\n sta REFP1\n\tlda NewCOLUP1,X\n\tsta COLUP1\t\t\t;+7\t27\n\n;\tlda SpriteGfxIndex,X\t;+4\t31\n;\ttax\t\t\t\t;+2\t33\n;fuck2\n\tlda P1Bottom\t\t;+3\t36\n\tsec\t\t\t\t;+2\t38\n\tsbc spriteheight,X\t;+4\t42\n\tsta P1Bottom\t\t;+3\t45\n\n\n\tlda player1pointerlo,X\t;+4\t49\n\tsbc P1Bottom\t\t;+3\t52\tcarry should still be set\n\tsta P1display\t\t;+3\t55\n\tlda player1pointerhi,X\n\tsta P1display+1\t\t;+7\t62\n\n\n\tcpy bally\n\tphp\t\t\t;+6\t68\tVDELed\n\n\tcpy missile1y\n\tphp\t\t\t;+6\t74\n\n\tcpy missile0y\n\tphp\t\t\t;+6\t 4\n\n\n\n; lda SpriteGfxIndex-1,x\n; sleep 3\n\tdec SpriteIndex\t;+5\t13\n; tax\n; lda NewSpriteY,x\n; sta RepoLine\n\n; 10 cycles below...\n\tbpl SetNextLine\n\tlda #255\n\tjmp SetLastLine\nSetNextLine\n;\tlda NewSpriteY-1,x\n\tlda.w temp6\nSetLastLine\n\tsta RepoLine\t\n\n tya\n and pfheight\n bne nodec\n dec pfpixelheight\n\tdey\t\t\t;+2\t30\n\n; 10 cycles \n \n\n\tjmp BackFromRepoKernel\t;+3\t43\n\nnodec\n sleep 4\n dey\n jmp BackFromRepoKernel\n\n;-------------------------------------------------------------------------\n\n\nSwitchDrawP0KV\t\t\t\t;\t69\n\tlda P0Bottom\n\tsta P0Top\t\t\t;+6\t75\n\tjmp BackFromSwitchDrawP0KV\t;+3\t 2\n\nWaitDrawP0KV\t\t\t\t;\t71\n\tSLEEP 4\t\t\t\t;+4\t75\n\tjmp BackFromSwitchDrawP0KV\t;+3\t 2\n\n;-------------------------------------------------------------------------\n\nDoneWithKernel\n\nBottomOfKernelLoop\n\n\tsta WSYNC\n ldx stack1\n txs\n jsr sixdigscore ; set up score\n\n\n sta WSYNC\n ldx #0\n sta HMCLR\n                STx GRP0\n                STx GRP1 ; seems to be needed because of vdel\n\n                LDY #7\n        STy VDELP0\n        STy VDELP1\n        LDA #$10\n        STA HMP1\n               LDA scorecolor \n                STA COLUP0\n                STA COLUP1\n \n        LDA #$03\n        STA NUSIZ0\n        STA NUSIZ1\n\n                STA RESP0\n                STA RESP1\n\n sleep 9\n lda  (scorepointers),y\n sta  GRP0\n ifconst pfscore\n lda pfscorecolor\n sta COLUPF\n else\n sleep 6\n endif\n\n                STA HMOVE\n lda  (scorepointers+8),y\n; sta WSYNC\n ;sleep 2\n jmp beginscore\n\n\nloop2\n lda  (scorepointers),y     ;+5  68  204\n sta  GRP0            ;+3  71  213      D1     --      --     --\n ifconst pfscore\n lda.w pfscore1\n sta PF1\n else\n sleep 7\n endif\n ; cycle 0\n lda  (scorepointers+$8),y  ;+5   5   15\nbeginscore\n sta  GRP1            ;+3   8   24      D1     D1      D2     --\n lda  (scorepointers+$6),y  ;+5  13   39\n sta  GRP0            ;+3  16   48      D3     D1      D2     D2\n lax  (scorepointers+$2),y  ;+5  29   87\n txs\n lax  (scorepointers+$4),y  ;+5  36  108\n sleep 3\n ifconst pfscore\n lda pfscore2\n sta PF1\n else\n sleep 6\n endif\n lda  (scorepointers+$A),y  ;+5  21   63\n stx  GRP1            ;+3  44  132      D3     D3      D4     D2!\n tsx\n stx  GRP0            ;+3  47  141      D5     D3!     D4     D4\n sta  GRP1            ;+3  50  150      D5     D5      D6     D4!\n sty  GRP0            ;+3  53  159      D4*    D5!     D6     D6\n dey\n bpl  loop2           ;+2  60  180\n \tldx stack1\n\ttxs\n\n\n; lda scorepointers+1\n ldy temp1\n; sta temp1\n sty scorepointers+1\n\n                LDA #0   \n               STA GRP0\n                STA GRP1\n sta PF1 \n       STA VDELP0\n        STA VDELP1;do we need these\n        STA NUSIZ0\n        STA NUSIZ1\n\n; lda scorepointers+3\n ldy temp3\n; sta temp3\n sty scorepointers+3\n\n; lda scorepointers+5\n ldy temp5\n; sta temp5\n sty scorepointers+5\n\n\n;-------------------------------------------------------------------------\n;------------------------Overscan Routine---------------------------------\n;-------------------------------------------------------------------------\n\nOverscanRoutine\n\n\n\nskipscore\n\tlda #2\n\tsta WSYNC\n\tsta VBLANK\t;turn on VBLANK\n\n\n\t\n\n\n;-------------------------------------------------------------------------\n;----------------------------End Main Routines----------------------------\n;-------------------------------------------------------------------------\n\n\n;*************************************************************************\n\n;-------------------------------------------------------------------------\n;----------------------Begin Subroutines----------------------------------\n;-------------------------------------------------------------------------\n\n\n\n\nKernelCleanupSubroutine\n\n\tldx #4\nAdjustYValuesDownLoop\n\tlda NewSpriteY,X\n\tsec\n\tsbc #2\n\tsta NewSpriteY,X\n\tdex\n\tbpl AdjustYValuesDownLoop\n\n\n RETURN\n\t;rts\n\nSetupP1Subroutine\n; flickersort algorithm\n; count 4-0\n; table2=table1 (?)\n; detect overlap of sprites in table 2\n; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed\n; if no overlap, do regular sort in table 2 and table 1\n ldx #255\ncopytable\n inx\n lda spritesort,x\n sta SpriteGfxIndex,x\n cpx #4\n bne copytable\n\n stx temp3 ; highest displayed sprite\n dex\n stx temp2\nsortloop\n ldx temp2\n lda spritesort,x\n tax\n lda NewSpriteY,x\n sta temp1\n\n ldx temp2\n lda spritesort+1,x\n tax\n lda NewSpriteY,x\n sec\n sbc temp1\n bcc largerXislower\n\n; larger x is higher (A>=temp1)\n cmp spriteheight,x\n bcs countdown\n; overlap with x+1>x\n; \n; stick x at end of gfxtable, dec counter\noverlapping\n dec temp3\n ldx temp2\n inx\n jsr shiftnumbers\n jmp skipswapGfxtable\n\nlargerXislower ; (temp1>A)\n tay\n ldx temp2\n lda spritesort,x\n tax\n tya\n eor #$FF\n cmp spriteheight,x\n bcs notoverlapping\n\n dec temp3\n ldx temp2\n inx\n jsr shiftnumbers\n jmp skipswapGfxtable \nnotoverlapping\n ldx temp2 ; swap display table\n ldy SpriteGfxIndex+1,x\n lda SpriteGfxIndex,x\n sty SpriteGfxIndex,x\n sta SpriteGfxIndex+1,x \n\nskipswapGfxtable\n ldx temp2 ; swap sort table\n ldy spritesort+1,x\n lda spritesort,x\n sty spritesort,x\n sta spritesort+1,x \n\ncountdown\n dec temp2\n bpl sortloop\n\nchecktoohigh\n ldx temp3\n lda SpriteGfxIndex,x\n tax\n lda NewSpriteY,x\n ifconst screenheight\n cmp #screenheight-2\n else\n cmp #$56\n endif\n bcc nonetoohigh\n dec temp3\n bne checktoohigh\n\nnonetoohigh\n rts\n\n\nshiftnumbers\n ; stick current x at end, shift others down\n ; if x=4: don't do anything\n ; if x=3: swap 3 and 4\n ; if x=2: 2=3, 3=4, 4=2\n ; if x=1: 1=2, 2=3, 3=4, 4=1\n ; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0\n ldy SpriteGfxIndex,x\nswaploop\n cpx #4\n beq shiftdone \n lda SpriteGfxIndex+1,x\n sta SpriteGfxIndex,x\n inx\n jmp swaploop\nshiftdone\n sty SpriteGfxIndex,x\n rts\n\n ifconst debugscore\ndebugcycles\n   ldx #14\n   lda INTIM ; display # cycles left in the score\n\n ifconst mincycles\n lda mincycles \n cmp INTIM\n lda mincycles\n bcc nochange\n lda INTIM\n sta mincycles\nnochange\n endif\n\n;   cmp #$2B\n;   bcs no_cycles_left\n   bmi cycles_left\n   ldx #64\n   eor #$ff ;make negative\ncycles_left\n   stx scorecolor\n   and #$7f ; clear sign bit\n   tax\n   lda scorebcd,x\n   sta score+2\n   lda scorebcd1,x\n   sta score+1\n   rts\nscorebcd\n .byte $00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40\n .byte $04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44\n .byte $08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48\n .byte $12, $76, $40, $04, $68, $32, $96, $60, $24, $88\nscorebcd1\n .byte 0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6\n .byte 7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13\n .byte $14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20\n .byte $21, $21, $22, $23, $23, $24, $24, $25, $26, $26\n endif\n",
   "default.inc":";\n; Inclues go below - order is crucial, since this is also the order in which\n; they will appear in the generated assembly file\n;\n\n\n; header file\n2600basicheader.asm\n\n\n; standard kernel: two players, two missiles, a ball and an asymmetric playfield.\nstd_kernel.asm\n\n; standard startup routine.\nstartup.asm\n\n\n; below are collections of subroutines and functions\n; if you have any more to add, put them immediately below this line.\n\npf_drawing.asm\npf_scrolling.asm\nstd_routines.asm\n\n; The overscan routine goes below.  it sets up sprites for the std_kernel.\n; if you have any routines that will not run until the overscan period,\n; put them immediately below this line.\nstd_overscan.asm\n\n\n; below is the generated batari Basic file\n\nbB.asm\n\n\n; score graphics.\nscore_graphics.asm\n\n; below is the footer, which contains the score digits and startup vectors.\n; If you want to create your own custom score digits, you may hack the file below,\n; but first you should rename it to something else.\n\n2600basicfooter.asm\n",
   "superchipheader.asm":" processor 6502\n include \"vcs.h\"\n include \"macro.h\"\n include \"2600basic.h\"\n include \"2600basic_variable_redefs.h\"\n ifconst bankswitch\n  if bankswitch == 8\n     ORG $1000\n     RORG $D000\n  endif\n  if bankswitch == 16\n     ORG $1000\n     RORG $9000\n  endif\n  if bankswitch == 32\n     ORG $1000\n     RORG $1000\n  endif\n else\n   ORG $F000\n endif\n repeat 256\n .byte $ff\n repend\n",
   "pf_scrolling.asm":"pfscroll ;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)\n bne notleft\n;left\n ifconst pfres\n ldx #pfres*4\n else\n ldx #48\n endif\nleftloop\n lda playfield-1,x\n lsr\n\n ifconst superchip\n lda playfield-2,x\n rol\n sta playfield-130,x\n lda playfield-3,x\n ror\n sta playfield-131,x\n lda playfield-4,x\n rol\n sta playfield-132,x\n lda playfield-1,x\n ror\n sta playfield-129,x\n else\n rol playfield-2,x\n ror playfield-3,x\n rol playfield-4,x\n ror playfield-1,x\n endif\n\n txa\n sbx #4\n bne leftloop\n RETURN\n\nnotleft\n lsr\n bcc notright\n;right\n\n ifconst pfres\n ldx #pfres*4\n else\n ldx #48\n endif\nrightloop\n lda playfield-4,x\n lsr\n ifconst superchip\n lda playfield-3,x\n rol\n sta playfield-131,x\n lda playfield-2,x\n ror\n sta playfield-130,x\n lda playfield-1,x\n rol\n sta playfield-129,x\n lda playfield-4,x\n ror\n sta playfield-132,x\n else\n rol playfield-3,x\n ror playfield-2,x\n rol playfield-1,x\n ror playfield-4,x\n endif\n txa\n sbx #4\n bne rightloop\n  RETURN\n\nnotright\n lsr\n bcc notup\n;up\n lsr\n bcc onedecup\n dec playfieldpos\nonedecup\n dec playfieldpos\n beq shiftdown \n bpl noshiftdown2 \nshiftdown\n  ifconst pfrowheight\n lda #pfrowheight\n else\n ifnconst pfres\n   lda #8\n else\n   lda #(96/pfres) ; try to come close to the real size\n endif\n endif\n\n sta playfieldpos\n lda playfield+3\n sta temp4\n lda playfield+2\n sta temp3\n lda playfield+1\n sta temp2\n lda playfield\n sta temp1\n ldx #0\nup2\n lda playfield+4,x\n ifconst superchip\n sta playfield-128,x\n lda playfield+5,x\n sta playfield-127,x\n lda playfield+6,x\n sta playfield-126,x\n lda playfield+7,x\n sta playfield-125,x\n else\n sta playfield,x\n lda playfield+5,x\n sta playfield+1,x\n lda playfield+6,x\n sta playfield+2,x\n lda playfield+7,x\n sta playfield+3,x\n endif\n txa\n sbx #252\n ifconst pfres\n cpx #(pfres-1)*4\n else\n cpx #44\n endif\n bne up2\n\n lda temp4\n \n ifconst superchip\n ifconst pfres\n sta playfield+pfres*4-129\n lda temp3\n sta playfield+pfres*4-130\n lda temp2\n sta playfield+pfres*4-131\n lda temp1\n sta playfield+pfres*4-132\n else\n sta playfield+47-128\n lda temp3\n sta playfield+46-128\n lda temp2\n sta playfield+45-128\n lda temp1\n sta playfield+44-128\n endif\n else\n ifconst pfres\n sta playfield+pfres*4-1\n lda temp3\n sta playfield+pfres*4-2\n lda temp2\n sta playfield+pfres*4-3\n lda temp1\n sta playfield+pfres*4-4\n else\n sta playfield+47\n lda temp3\n sta playfield+46\n lda temp2\n sta playfield+45\n lda temp1\n sta playfield+44\n endif\n endif\nnoshiftdown2\n RETURN\n\n\nnotup\n;down\n lsr\n bcs oneincup\n inc playfieldpos\noneincup\n inc playfieldpos\n lda playfieldpos\n\n  ifconst pfrowheight\n cmp #pfrowheight+1\n else\n ifnconst pfres\n   cmp #9\n else\n   cmp #(96/pfres)+1 ; try to come close to the real size\n endif\n endif\n\n bcc noshiftdown \n lda #1\n sta playfieldpos\n\n ifconst pfres\n lda playfield+pfres*4-1\n sta temp4\n lda playfield+pfres*4-2\n sta temp3\n lda playfield+pfres*4-3\n sta temp2\n lda playfield+pfres*4-4\n else\n lda playfield+47\n sta temp4\n lda playfield+46\n sta temp3\n lda playfield+45\n sta temp2\n lda playfield+44\n endif\n\n sta temp1\n\n ifconst pfres\n ldx #(pfres-1)*4\n else\n ldx #44\n endif\ndown2\n lda playfield-1,x\n ifconst superchip\n sta playfield-125,x\n lda playfield-2,x\n sta playfield-126,x\n lda playfield-3,x\n sta playfield-127,x\n lda playfield-4,x\n sta playfield-128,x\n else\n sta playfield+3,x\n lda playfield-2,x\n sta playfield+2,x\n lda playfield-3,x\n sta playfield+1,x\n lda playfield-4,x\n sta playfield,x\n endif\n txa\n sbx #4\n bne down2\n\n lda temp4\n ifconst superchip\n sta playfield-125\n lda temp3\n sta playfield-126\n lda temp2\n sta playfield-127\n lda temp1\n sta playfield-128\n else\n sta playfield+3\n lda temp3\n sta playfield+2\n lda temp2\n sta playfield+1\n lda temp1\n sta playfield\n endif\nnoshiftdown\n RETURN\n",
   "std_routines.asm":";standard routines needed for pretty much all games\n; just the random number generator is left - maybe we should remove this asm file altogether?\n; repositioning code and score pointer setup moved to overscan\n; read switches, joysticks now compiler generated (more efficient)\n\nrandomize\n\tlda rand\n\tlsr\n ifconst rand16\n\trol rand16\n endif\n\tbcc noeor\n\teor #$B4\nnoeor\n\tsta rand\n ifconst rand16\n\teor rand16\n endif\n\tRETURN\n",
   "2600basicheader.asm":" processor 6502\n include \"vcs.h\"\n include \"macro.h\"\n include \"2600basic.h\"\n include \"2600basic_variable_redefs.h\"\n ifconst bankswitch\n  if bankswitch == 8\n     ORG $1000\n     RORG $D000\n  endif\n  if bankswitch == 16\n     ORG $1000\n     RORG $9000\n  endif\n  if bankswitch == 32\n     ORG $1000\n     RORG $1000\n  endif\n else\n   ORG $F000\n endif\n",
   "multisprite_bankswitch.inc":";\n; Inclues go below - order is crucial, since this is also the order in which\n; they will appear in the generated assembly file\n;\n; header file\nmultispriteheader.asm\n\n; this is the batari Basic file\n; for bankswitching, the concatenator will only parse until the end of \n; bank 1\nbB.asm\n\n; standard kernel: two players, two missiles, a ball and an asymmetric playfield.\nmultisprite_kernel.asm\n\n; standard startup routine.\nstartup.asm\n\n\n; below are collections of subroutines and functions\n; if you have any more to add, put them immediately below this line.\n\nstd_routines.asm\n\n; below is the generated batari Basic file\n; note: this file is generated by the concatenation program. \n; automatically split off from the bB.asm file where the new bank occurs\n\nbB2.asm\n\n\n; score gfx\nscore_graphics.asm\n\n;bankswitch support\nbanksw.asm\n\n\n; below is the footer, which contains the score digits and startup vectors.\n; If you want to create your own custom score digits, you may hack the file below,\n; but first you should rename it to something else.\n; also includes bankswitching support (if applicable)\n\n2600basicfooter.asm\n",
   "startup.asm":"start\n sei\n cld\n ldy #0\n lda $D0\n cmp #$2C               ;check RAM location #1\n bne MachineIs2600\n lda $D1\n cmp #$A9               ;check RAM location #2\n bne MachineIs2600\n dey\nMachineIs2600\n ldx #0\n txa\nclearmem\n inx\n txs\n pha\n bne clearmem\n sty temp1\n ifconst pfrowheight\n lda pfrowheight\n else\n ifconst pfres\n lda #(96/pfres)\n else\n lda #8\n endif\n endif\n sta playfieldpos\n ldx #5\ninitscore\n lda #<scoretable\n sta scorepointers,x \n dex\n bpl initscore\n lda #1\n sta CTRLPF\n ora INTIM\n sta rand\n\n ifconst multisprite\n   jsr multisprite_setup\n endif\n\n ifnconst bankswitch\n   jmp game\n else\n   lda #>(game-1)\n   pha\n   lda #<(game-1)\n   pha\n   pha\n   pha\n   ldx #1\n   jmp BS_jsr\n endif\n",
   "pf_drawing.asm":"; playfield drawing routines\n; you get a 32x12 bitmapped display in a single color :)\n; 0-31 and 0-11\n\npfclear ; clears playfield - or fill with pattern\n ifconst pfres\n ldx #pfres*4-1\n else\n ldx #47\n endif\npfclear_loop\n ifnconst superchip\n sta playfield,x\n else\n sta playfield-128,x\n endif\n dex\n bpl pfclear_loop\n RETURN\n \nsetuppointers\n stx temp2 ; store on.off.flip value\n tax ; put x-value in x \n lsr\n lsr\n lsr ; divide x pos by 8 \n sta temp1\n tya\n asl\n asl ; multiply y pos by 4\n clc\n adc temp1 ; add them together to get actual memory location offset\n tay ; put the value in y\n lda temp2 ; restore on.off.flip value\n rts\n\npfread\n;x=xvalue, y=yvalue\n jsr setuppointers\n lda setbyte,x\n and playfield,y\n eor setbyte,x\n; beq readzero\n; lda #1\n; readzero\n RETURN\n\npfpixel\n;x=xvalue, y=yvalue, a=0,1,2\n jsr setuppointers\n\n ifconst bankswitch\n lda temp2 ; load on.off.flip value (0,1, or 2)\n beq pixelon_r  ; if \"on\" go to on\n lsr\n bcs pixeloff_r ; value is 1 if true\n lda playfield,y ; if here, it's \"flip\"\n eor setbyte,x\n ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n RETURN\npixelon_r\n lda playfield,y\n ora setbyte,x\n ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n RETURN\npixeloff_r\n lda setbyte,x\n eor #$ff\n and playfield,y\n ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n RETURN\n\n else\n jmp plotpoint\n endif\n\npfhline\n;x=xvalue, y=yvalue, a=0,1,2, temp3=endx\n jsr setuppointers\n jmp noinc\nkeepgoing\n inx\n txa\n and #7\n bne noinc\n iny\nnoinc\n jsr plotpoint\n cpx temp3\n bmi keepgoing\n RETURN\n\npfvline\n;x=xvalue, y=yvalue, a=0,1,2, temp3=endx\n jsr setuppointers\n sty temp1 ; store memory location offset\n inc temp3 ; increase final x by 1 \n lda temp3\n asl\n asl ; multiply by 4\n sta temp3 ; store it\n ; Thanks to Michael Rideout for fixing a bug in this code\n ; right now, temp1=y=starting memory location, temp3=final\n ; x should equal original x value\nkeepgoingy\n jsr plotpoint\n iny\n iny\n iny\n iny\n cpy temp3\n bmi keepgoingy\n RETURN\n\nplotpoint\n lda temp2 ; load on.off.flip value (0,1, or 2)\n beq pixelon  ; if \"on\" go to on\n lsr\n bcs pixeloff ; value is 1 if true\n lda playfield,y ; if here, it's \"flip\"\n eor setbyte,x\n  ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n rts\npixelon\n lda playfield,y\n ora setbyte,x\n ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n rts\npixeloff\n lda setbyte,x\n eor #$ff\n and playfield,y\n ifconst superchip\n sta playfield-128,y\n else\n sta playfield,y\n endif\n rts\n\nsetbyte\n .byte $80\n .byte $40\n .byte $20\n .byte $10\n .byte $08\n .byte $04\n .byte $02\n .byte $01\n .byte $01\n .byte $02\n .byte $04\n .byte $08\n .byte $10\n .byte $20\n .byte $40\n .byte $80\n .byte $80\n .byte $40\n .byte $20\n .byte $10\n .byte $08\n .byte $04\n .byte $02\n .byte $01\n .byte $01\n .byte $02\n .byte $04\n .byte $08\n .byte $10\n .byte $20\n .byte $40\n .byte $80\n",
   "score_graphics.asm":"; feel free to modify the score graphics - just keep each digit 8 high\n; and keep the conditional compilation stuff intact\n ifconst ROM2k\n   ORG $F7AC\n else\n   ifconst bankswitch\n     if bankswitch == 8\n       ORG $2F94-bscode_length\n       RORG $FF94-bscode_length\n     endif\n     if bankswitch == 16\n       ORG $4F94-bscode_length\n       RORG $FF94-bscode_length\n     endif\n     if bankswitch == 32\n       ORG $8F94-bscode_length\n       RORG $FF94-bscode_length\n     endif\n   else\n     ORG $FF9C\n   endif\n endif\n\n\nscoretable\n       .byte %00111100\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %00111100\n\n       .byte %01111110\n       .byte %00011000\n       .byte %00011000\n       .byte %00011000\n       .byte %00011000\n       .byte %00111000\n       .byte %00011000\n       .byte %00001000\n\n       .byte %01111110\n       .byte %01100000\n       .byte %01100000\n       .byte %00111100\n       .byte %00000110\n       .byte %00000110\n       .byte %01000110\n       .byte %00111100\n\n       .byte %00111100\n       .byte %01000110\n       .byte %00000110\n       .byte %00000110\n       .byte %00011100\n       .byte %00000110\n       .byte %01000110\n       .byte %00111100\n\n       .byte %00001100\n       .byte %00001100\n       .byte %01111110\n       .byte %01001100\n       .byte %01001100\n       .byte %00101100\n       .byte %00011100\n       .byte %00001100\n\n       .byte %00111100\n       .byte %01000110\n       .byte %00000110\n       .byte %00000110\n       .byte %00111100\n       .byte %01100000\n       .byte %01100000\n       .byte %01111110\n\n       .byte %00111100\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %01111100\n       .byte %01100000\n       .byte %01100010\n       .byte %00111100\n\n       .byte %00110000\n       .byte %00110000\n       .byte %00110000\n       .byte %00011000\n       .byte %00001100\n       .byte %00000110\n       .byte %01000010\n       .byte %00111110\n\n       .byte %00111100\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %00111100\n       .byte %01100110\n       .byte %01100110\n       .byte %00111100\n\n       .byte %00111100\n       .byte %01000110\n       .byte %00000110\n       .byte %00111110\n       .byte %01100110\n       .byte %01100110\n       .byte %01100110\n       .byte %00111100 \n\n\n ifconst ROM2k\n   ORG $F7FC\n else\n   ifconst bankswitch\n     if bankswitch == 8\n       ORG $2FF4-bscode_length\n       RORG $FFF4-bscode_length\n     endif\n     if bankswitch == 16\n       ORG $4FF4-bscode_length\n       RORG $FFF4-bscode_length\n     endif\n     if bankswitch == 32\n       ORG $8FF4-bscode_length\n       RORG $FFF4-bscode_length\n     endif\n   else\n     ORG $FFFC\n   endif\n endif\n",
   "pfread_msk.asm":"pfread\n cmp #16\n bcc lefthalf\n eor #31 ; 16-31 converted to 15-0\nlefthalf\n tax\n lda bytemask,x\n cpx #8\n bcc bytedone\n and (PF2pointer),y\n .byte $0C\nbytedone\n and (PF1pointer),y\n RETURN\nbytemask\n .byte $80,$40,$20,$10,8,4,2,1\n .byte 1,2,4,8,$10,$20,$40,$80\n",
   "fixed_point_math.asm":"; Fixed point math routines - created by AtariAge member djmips\n; some changes by Fred Quimby\n\n;assignment from 8.8 to 4.4\n\nAssign88to44:\n\n      ; A(4.4) = A,X(8.8)\n\n       stx temp1\n       rol temp1\n       asl\n       rol temp1\n       asl\n       rol temp1\n       asl\n       rol temp1\n       asl\n       rts\n\n;assignment from 4.4 to 8.8\n;\n\nAssign44to88:\n\n      ; A,X(8.8) = A(4.4)\n\n       sta temp1\n       lda #0\n       asl temp1\n       sbc #0   ;\n       eor #$ff ; do sign extend\n       rol\n       asl temp1\n       rol\n       asl temp1\n       rol\n       asl temp1\n       rol\n       ldx temp1\n       rts\n\n ifconst bankswitch\nAssign88to44bs:\n\n      ; A(4.4) = A,X(8.8)\n\n       stx temp1\n       rol temp1\n       asl\n       rol temp1\n       asl\n       rol temp1\n       asl\n       rol temp1\n       asl\n       RETURN\n\n;assignment from 4.4 to 8.8\n;\n\nAssign44to88bs:\n\n      ; A,X(8.8) = A(4.4)\n\n       sta temp1\n       lda #0\n       asl temp1\n       sbc #0   ;\n       eor #$ff ; do sign extend\n       rol\n       asl temp1\n       rol\n       asl temp1\n       rol\n       asl temp1\n       rol\n       ldx temp1\n       RETURN\n endif\n\n;\n;Addition/subtraction asm procedures:\n\n;add/sub 8.8 to/from 4.4\n\nAdd88to44:\n\n      ; A(4.4) = A,X(8.8) + Y(4.4)\n\n       jsr Assign88to44\n       sty temp1\n       clc\n       adc temp1\n       rts\n\nSub88from44:\n\n      ; A(4.4) = A,X(8.8) - Y(4.4)\n\n       jsr Assign88to44\n       sty temp1\n       sec\n       sbc temp1\n       rts\n\n\nAdd44to88:\n\n      ; A,X(8.8) = A,X(8.8) + Y(4.4)\n\n       sta temp2\n       stx temp3\n       tya\n       jsr Assign44to88\n       clc\n       sta temp1\n       txa\n       adc temp3\n       tax\n       lda temp1\n       adc temp2\n       rts\n\n\nSub44from88:\n\n      ; A,X(8.8) = A,X(8.8) - Y(4.4)\n\n       sta temp2\n       stx temp3\n       tya\n       jsr Assign44to88\n       sec\n       sta temp1\n       lda temp3\n       stx temp3\n       sbc temp3\n       tax\n       lda temp2\n       sbc temp1\n       rts\n\n",
   "multisprite.h":"missile0x = $80\nmissile1x = $81\nballx = $82\n\nobjecty = $83\nmissile0y = $83\nmissile1y = $84\nbally = $85\n\n; multisprite stuff below - 5 bytes each starting with spritex\n\nSpriteIndex = $86\n\nplayer0x = $87\nNewSpriteX = $88\t\t;\t\tX position\nplayer1x = $88\nplayer2x = $89\nplayer3x = $8A\nplayer4x = $8B\nplayer5x = $8C\n\nplayer0y = $8D\nNewSpriteY = $8E\t\t\t;\t\tY position\nplayer1y = $8E\nplayer2y = $8F\nplayer3y = $90\nplayer4y = $91\nplayer5y = $92\n\nNewNUSIZ = $93\n_NUSIZ1 = $93\nNUSIZ2 = $94\nNUSIZ3 = $95\nNUSIZ4 = $96\nNUSIZ5 = $97\n\nNewCOLUP1 = $98\n_COLUP1 = $98\nCOLUP2 = $99\nCOLUP3 = $9A\nCOLUP4 = $9B\nCOLUP5 = $9C\n\nSpriteGfxIndex = $9D\n\nplayer0pointer = $A2\nplayer0pointerlo = $A2\nplayer0pointerhi = $A3\n\n;P0Top = $A4\nP0Top = temp5\nP0Bottom = $A4\nP1Bottom = $A5\n\nplayer1pointerlo = $A6\nplayer2pointerlo = $A7\nplayer3pointerlo = $A8\nplayer4pointerlo = $A9\nplayer5pointerlo = $AA\n\nplayer1pointerhi = $AB\nplayer2pointerhi = $AC\nplayer3pointerhi = $AD\nplayer4pointerhi = $AE\nplayer5pointerhi = $AF\n\nplayer0height = $B0\nspriteheight = $B1 ; heights of multiplexed player sprite\nplayer1height = $B1\nplayer2height = $B2\nplayer3height = $B3\nplayer4height = $B4\nplayer5height = $B5\n\nPF1temp1 = $B6\nPF1temp2 = $B7\nPF2temp1 = $B8\nPF2temp2 = $B9\n\npfpixelheight = $BA\n\n; playfield is now a pointer to graphics\nplayfield = $BB\nPF1pointer = $BB\n\nPF2pointer = $BD\n\nstatusbarlength = $BF\naux3 = $BF\n\nlifecolor = $C0\npfscorecolor = $C0\naux4 = $C0\n\nP1display = temp2 ; temp2 and temp3\nlifepointer = $c1\nlives = $c2\npfscore1 = $c1\npfscore2 = $c2\naux5 = $c1\naux6 = $c2\n\nplayfieldpos = $C3\n\nRepoLine = temp4\n\nscorepointers = $C4\n\ntemp1 = $CA ;used by kernel.  can be used in program too, but\ntemp2 = $CB ;are obliterated when drawscreen is called.\ntemp3 = $CC\ntemp4 = $CD\ntemp5 = $CE\ntemp6 = $CF\ntemp7 = $D0 ; This is used to aid in bankswitching\n\nscore = $D1\npfheight = $D4\nscorecolor = $D5 ;need to find other places for these, possibly...\nrand = $D6\n\n\n\nA = $d7\na = $d7\nB = $d8\nb = $d8\nC = $d9\nc = $d9\nD = $da\nd = $da\nE = $db\ne = $db\nF = $dc\nf = $dc\nG = $dd\ng = $dd\nH = $de\nh = $de\nI = $df\ni = $df\nJ = $e0\nj = $e0\nK = $e1\nk = $e1\nL = $e2\nl = $e2\nM = $e3\nm = $e3\nN = $e4\nn = $e4\nO = $e5\no = $e5\nP = $e6\np = $e6\nQ = $e7\nq = $e7\nR = $e8\nr = $e8\nS = $e9\ns = $e9\nT = $ea\nt = $ea\nU = $eb\nu = $eb\nV = $ec\nv = $ec\nW = $ed\nw = $ed\nX = $ee\nx = $ee\nY = $ef\ny = $ef\nZ = $f0\nz = $f0\n\nspritesort = $f1 ; helps with flickersort\nspritesort2 = $f2 ; helps with flickersort\nspritesort3 = $f3\nspritesort4 = $f4\nspritesort5 = $f5\n\nstack1 = $f6\nstack2 = $f7\nstack3 = $f8\nstack4 = $f9\n; the stack bytes above may be used in the kernel\n; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF\n\n MAC RETURN\t; auto-return from either a regular or bankswitched module\n   ifnconst bankswitch\n     rts\n   else\n     jmp BS_return\n   endif\n ENDM\n\n\n",
   "multisprite.inc":";\n; Inclues go below - order is crucial, since this is also the order in which\n; they will appear in the generated assembly file\n;\n\n\n; header file\n multispriteheader.asm\n\n\nmultisprite_kernel.asm\n\n; standard startup routine.\nstartup.asm\n\n\n; below are collections of subroutines and functions\n; if you have any more to add, put them immediately below this line.\n\nstd_routines.asm\n\n; The overscan routine goes below.  it sets up sprites for the std_kernel.\n; if you have any routines that will not run until the overscan period,\n; put them immediately below this line.\n\n\n; below is the generated batari Basic file\n\nbB.asm\n\n\n; score graphics.\nscore_graphics.asm\n\n; below is the footer, which contains the score digits and startup vectors.\n; If you want to create your own custom score digits, you may hack the file below,\n; but first you should rename it to something else.\n\n2600basicfooter.asm\n"
}